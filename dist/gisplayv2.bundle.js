var lol = 3;
var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/ES6Test/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //@TODO Estas variaveis ate a classe sao para remover\n\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Choropleth */ 5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        console.log(\"Gisplay Class constructor\");\n        window.profiling = true;\n        window.maps = new Array();\n        window.mapcount = 0;\n\n        //WebGL API\n        window._vertexcount = 0;\n        window._tricount = 0;\n        return this;\n    }\n\n    _createClass(Gisplay, [{\n        key: \"makeChoropleth\",\n        value: function makeChoropleth(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            /*console.log(options)*/\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            this.makeMap(gismap, options); //options.defaultid);\n        }\n    }, {\n        key: \"makeDotMap\",\n        value: function makeDotMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new DotMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeProportionalSymbolsMap\",\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new PSymbolsMap(bgmap, geometry, options);\n            this.makeMap(gismap);\n        }\n    }, {\n        key: \"makeChangeMap\",\n        value: function makeChangeMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new ChangeMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeChorochromaticMap\",\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new ChorochromaticMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeMap\",\n        value: function makeMap(gismap, options) {\n            var _this = this;\n\n            var defaultid = options.defaultid;\n            setTimeout(function (console) {\n                /*alert(this.profiling);*/\n                var start = 0;\n                if (_this.profiling == true) start = Date.now();\n                defaultid = defaultid != null ? defaultid : 1;\n                if (gismap.colorscheme == undefined) gismap.colorscheme = gismap.defaults(defaultid).colorScheme;\n                if (gismap.classbreaks == undefined) {\n                    if (gismap.numberofclasses == undefined) {\n                        gismap.numberofclasses = gismap.defaults(defaultid).numberOfClasses;\n                    }\n                    gismap.preProcessData(gismap.geometry, gismap.numberofclasses, gismap.algorithm, gismap.colorscheme);\n                }\n\n                //gismap.processData(gismap.geometry);\n                gismap.loadGeoJSON(gismap.geometry);\n                var start2 = 0;\n                if (_this.profiling == true) {\n                    start2 = Date.now();\n                    window.console.log(\"Tempo de processamento do dados (segundos): \" + (start2 - start) / 1000);\n                }\n                gismap.draw();\n\n                var end = 0;\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log(\"Tempo de desenho do mapa (segundos): \" + (end - start2) / 1000);\n                }\n                if (options.legend != false) gismap.buildLegend();\n                if (options.loader != false) {\n                    gismap.loader();\n                }\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log(\"Tempo total (segundos): \" + (end - _this.startTimeStamp) / 1000);\n                }\n            }, 1);\n        }\n    }, {\n        key: \"changemapDefaults\",\n        value: function changemapDefaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9HaXNwbGF5LmpzPzI2Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy9AVE9ETyBFc3RhcyB2YXJpYXZlaXMgYXRlIGEgY2xhc3NlIHNhbyBwYXJhIHJlbW92ZXJcclxuaW1wb3J0IHtDaG9yb3BsZXRofSBmcm9tICcuL01hcHMvQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogR2lzcGxheSBBUEkgd2l0aCBvbmUgbWV0aG9kIGZvciBlYWNoIG1hcCBhdmFpbGFibGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheSB7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2lzcGxheSBDbGFzcyBjb25zdHJ1Y3RvclwiKTtcclxuICAgICAgICB3aW5kb3cucHJvZmlsaW5nID0gdHJ1ZTtcclxuICAgICAgICB3aW5kb3cubWFwcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHdpbmRvdy5tYXBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgIC8vV2ViR0wgQVBJXHJcbiAgICAgICAgd2luZG93Ll92ZXJ0ZXhjb3VudCA9IDA7XHJcbiAgICAgICAgd2luZG93Ll90cmljb3VudCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZUNob3JvcGxldGgoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIC8qY29uc29sZS5sb2cob3B0aW9ucykqL1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7Ly9vcHRpb25zLmRlZmF1bHRpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZURvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IERvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMuZGVmYXVsdGlkKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbWFrZVByb3BvcnRpb25hbFN5bWJvbHNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBQU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBtYWtlQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucy5kZWZhdWx0aWQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBtYWtlQ2hvcm9jaHJvbWF0aWNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb2Nocm9tYXRpY01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMuZGVmYXVsdGlkKTtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlTWFwKGdpc21hcCwgb3B0aW9ucykge1xyXG4gICAgICAgIGxldCAgZGVmYXVsdGlkID0gb3B0aW9ucy5kZWZhdWx0aWQ7XHJcbiAgICAgICAgc2V0VGltZW91dChjb25zb2xlID0+IHtcclxuICAgICAgICAgICAgLyphbGVydCh0aGlzLnByb2ZpbGluZyk7Ki9cclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHRpZCA9IGRlZmF1bHRpZCAhPSBudWxsID8gZGVmYXVsdGlkIDogMTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jb2xvcnNjaGVtZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBnaXNtYXAuY29sb3JzY2hlbWUgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5jb2xvclNjaGVtZTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jbGFzc2JyZWFrcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnaXNtYXAubnVtYmVyb2ZjbGFzc2VzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdpc21hcC5udW1iZXJvZmNsYXNzZXMgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnaXNtYXAucHJlUHJvY2Vzc0RhdGEoZ2lzbWFwLmdlb21ldHJ5LCBnaXNtYXAubnVtYmVyb2ZjbGFzc2VzLCBnaXNtYXAuYWxnb3JpdGhtLCBnaXNtYXAuY29sb3JzY2hlbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dpc21hcC5wcm9jZXNzRGF0YShnaXNtYXAuZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICBnaXNtYXAubG9hZEdlb0pTT04oZ2lzbWFwLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0MiA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDIgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRvIGRhZG9zIChzZWd1bmRvcyk6ICR7KHN0YXJ0MiAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2lzbWFwLmRyYXcoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBlbmQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgZGVzZW5obyBkbyBtYXBhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0MikgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZCAhPSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIGdpc21hcC5idWlsZExlZ2VuZCgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGdpc21hcC5sb2FkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gdG90YWwgKHNlZ3VuZG9zKTogJHsoZW5kIC0gdGhpcy5zdGFydFRpbWVTdGFtcCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlbWFwRGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9FUzZUZXN0L0dpc3BsYXkuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTs7O0FBR0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/ES6Test/Aesthetic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Aesthetic = exports.Aesthetic = function () {\n    function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n        _classCallCheck(this, Aesthetic);\n\n        this.id = id;\n        this.fillColor = fcolor;\n        this.strokeColor = stroke;\n        this.range = range;\n        this._attr = attr;\n        this.pointSize = pointsize == null ? 1.0 : parseFloat(pointsize);\n        this._features = new Array();\n        this._allFeatures = null;\n        this.enabled = true;\n        this.outer = false;\n        return this;\n    }\n\n    _createClass(Aesthetic, [{\n        key: 'addFeature',\n        value: function addFeature(id, properties, triangles, borders, points) {\n            this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n        }\n    }, {\n        key: 'getAttr',\n        value: function getAttr() {\n            return this._attr;\n        }\n    }, {\n        key: 'checkProperty',\n        value: function checkProperty(value) {\n            if (this.range == null) return true;else {\n                if (typeof value === 'number') {\n\n                    return (this.range[0] == null || value >= this.range[0]) && (this.range[1] == null || value < this.range[1] || value <= this.range[1] && this.outer == true);\n                } else return value == this.range[0];\n            }\n        }\n    }, {\n        key: 'addGroupedFeature',\n        value: function addGroupedFeature(id, triangles, borders, points) {\n            if (this._allFeatures == null) {\n                this._allFeatures = new Array();\n                this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n            } else {\n                var cursor = 0; //TODO\n                //this._allFeatures[0]._properties.push(properties);\n                this._allFeatures[cursor].push(new _Feature.Feature(id, null, triangles, borders, points));\n                //this._allFeatures[cursor]._triangles.concat(triangles);\n                //this._allFeatures[cursor]._borders.concat(borders);\n            }\n        }\n    }, {\n        key: 'enableDisable',\n        value: function enableDisable() {\n            this.enabled = !this.enabled;\n            return this.enabled;\n        }\n    }]);\n\n    return Aesthetic;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9BZXN0aGV0aWMuanM/ZDRhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ZlYXR1cmV9IGZyb20gJy4vRmVhdHVyZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgQWVzdGhldGljIHtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IoaWQsIGF0dHIsIGZjb2xvciwgc3Ryb2tlLCBwb2ludHNpemUsIHJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBzdHJva2U7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIHRoaXMuX2F0dHIgPSBhdHRyO1xyXG4gICAgICAgIHRoaXMucG9pbnRTaXplID0gcG9pbnRzaXplID09IG51bGwgPyAxLjAgOiBwYXJzZUZsb2F0KHBvaW50c2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEF0dHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHI7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmdlID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMucmFuZ2VbMF0gPT0gbnVsbCB8fCB2YWx1ZSA+PSB0aGlzLnJhbmdlWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICh0aGlzLnJhbmdlWzFdID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlIDwgdGhpcy5yYW5nZVsxXSB8fCAodmFsdWUgPD0gdGhpcy5yYW5nZVsxXSAmJiB0aGlzLm91dGVyID09IHRydWUpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT0gdGhpcy5yYW5nZVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEdyb3VwZWRGZWF0dXJlKGlkLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbGxGZWF0dXJlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSAwOyAvL1RPRE9cclxuICAgICAgICAgICAgLy90aGlzLl9hbGxGZWF0dXJlc1swXS5fcHJvcGVydGllcy5wdXNoKHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlc1tjdXJzb3JdLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxsRmVhdHVyZXNbY3Vyc29yXS5fdHJpYW5nbGVzLmNvbmNhdCh0cmlhbmdsZXMpO1xyXG4gICAgICAgICAgICAvL3RoaXMuX2FsbEZlYXR1cmVzW2N1cnNvcl0uX2JvcmRlcnMuY29uY2F0KGJvcmRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVEaXNhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvRVM2VGVzdC9BZXN0aGV0aWMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/ES6Test/Feature.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n/**\r\n * \r\n */\nvar Feature = exports.Feature = function Feature(id, properties, triangles, borders, points) {\n    _classCallCheck(this, Feature);\n\n    this._id = id;\n    this._properties = properties;\n    this._triangles = triangles;\n    this._borders = borders;\n    this._points = points;\n    return this;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9GZWF0dXJlLmpzP2JjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbnRlcm1lZGlhdGUgQVBJXHJcbi8qKlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcclxuICAgICAgICB0aGlzLl9ib3JkZXJzID0gYm9yZGVycztcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvRVM2VGVzdC9GZWF0dXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/ES6Test/Legend.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Legend = exports.Legend = function () {\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        this.title = title;\n        this.init(id);\n        return this;\n    }\n\n    _createClass(Legend, [{\n        key: 'insertLegend',\n        value: function insertLegend(map) {\n            this.legendDiv.appendChild(this.table);\n            map.getContainer().appendChild(this.legendDiv);\n        }\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 2);\n        }\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 1);\n        }\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (currentaes.outer == false) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n            value.appendChild(text);\n\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n            colorDiv.style['backgroundColor'] = rgbc;\n            if (type == 1) {\n                //polygon\n                colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                colorDiv.style.width = 80; //(mapCanvas.width / 10);\n                if (currentaes.strokeColor != null && currentaes != undefined) colorDiv.style['borderColor'] = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type == 2) {\n                //point\n                var size = void 0;\n                if (currentaes.pointSize != null) {\n                    size = Math.max(currentaes.pointSize, 5);\n                } else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (Gisplay.profiling == true) var start = Date.now();\n                if (mapobj.legendToggle != false) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade == true) {\n                        this.className += \" _gisplayfade\";\n                    } else {\n                        this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                }\n                if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                mapobj.draw();\n                if (Gisplay.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                }\n            };\n\n            this.table.appendChild(row);\n        }\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberof = 5;\n            if (mapobj.aesthetics.length > 5) numberof = mapobj.aesthetics.length;\n            var strcolor = '';\n            for (var i = 0; i < numberof; i++) {\n                var color = mapobj.fcolor(i / numberof).rgb();\n                strcolor += ',rgba(' + Math.round(color[0]) + ',' + Math.round(color[1]) + ',' + Math.round(color[2]) + ',' + mapobj.alpha + ')';\n            }\n            strcolor += ') ';\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor;\n\n            valueDiv.style.height = 25; //(mapCanvas.height / 10);\n            valueDiv.style.width = 130; //(mapCanvas.width / 10);\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            value2.colSpan = 2;\n\n            var divleft = document.createElement('div');\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n    }, {\n        key: 'init',\n        value: function init(id, classname) {\n            //console.log(\"id == \" + id);\n            var mapCanvas = document.getElementById('mapCanvas' + id);\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) {\n                this.legendDiv.className = classname;\n            } else {\n                this.legendDiv.className = '_gisplaylegendBR';\n            }\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n            //thcolor.style.width = 100;\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numberof) {\n            if (this.lastdiv == undefined) {\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else {\n                this.firstInsertion = false;\n            }\n\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + 1 + ')';\n            var strokecolor = void 0;\n\n            if (currentaes.strokeColor != null && currentaes != undefined) strokecolor = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numberof - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (this.firstInsertion == false && i == numberof - 1 || numberof == 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numberof - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(round(propvalue));\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgbc;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.maxpointsize - mapobj.minpointsize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (Gisplay.profiling == true) var start = Date.now();\n                    if (mapobj.legendToggle != false) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade == true) {\n                            this.className += \" _gisplayfade\";\n                        } else {\n                            this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                        }\n                    }\n                    if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                    mapobj.draw();\n                    if (Gisplay.profiling == true) {\n                        var end = Date.now();\n                        window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                    }\n                    if (!e) var e = window.event;\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n                current.appendChild(colorDiv);\n                if ( /*i!= (numberof-1) &&*/this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n            if (this.firstInsertion == true) {\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9MZWdlbmQuanM/ZjBjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgTGVnZW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKGlkLCB0aXRsZSkge1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICB0aGlzLmluaXQoaWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydExlZ2VuZChtYXApIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZERpdi5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlKTtcclxuICAgICAgICBtYXAuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmREaXYpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFBvaW50Um93KGN1cnJlbnRhZXMsIG1hcG9iaikge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0Um93KGN1cnJlbnRhZXMsIG1hcG9iaiwgMik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UG9seWdvblJvdyhjdXJyZW50YWVzLCBtYXBvYmopIHtcclxuICAgICAgICB0aGlzLmluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIHR5cGUpIHtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIGxldCB0ZXh0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudGFlcy5yYW5nZVswXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluaW5wdXQgPSBjdXJyZW50YWVzLnJhbmdlWzBdICE9IG51bGwgPyBjdXJyZW50YWVzLnJhbmdlWzBdIDogbWFwb2JqLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4aW5wdXQgPSBjdXJyZW50YWVzLnJhbmdlWzFdICE9IG51bGwgPyBjdXJyZW50YWVzLnJhbmdlWzFdIDogbWFwb2JqLm1heDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMub3V0ZXIgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske21pbmlucHV0fSwgJHttYXhpbnB1dH1bYCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgWyR7bWluaW5wdXR9LCAke21heGlucHV0fV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VycmVudGFlcy5yYW5nZVswXSk7XHJcbiAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQodGV4dCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29sb3JEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzNdfSlgO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSA9IHJnYmM7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMSkgey8vcG9seWdvblxyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSAyNTsvLyhtYXBDYW52YXMuaGVpZ2h0IC8gMTApO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IDgwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMuc3Ryb2tlQ29sb3IgIT0gbnVsbCAmJiBjdXJyZW50YWVzICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlWydib3JkZXJDb2xvciddID0gYHJnYmEoJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzBdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMV19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclsyXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzNdfSlgO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlyZWN0YW5nbGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHsvL3BvaW50XHJcbiAgICAgICAgICAgIGxldCBzaXplO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudGFlcy5wb2ludFNpemUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRhZXMucG9pbnRTaXplLCA1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzaXplID0gMjU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5Y2lyY2xlJztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBjb2xvci5hcHBlbmRDaGlsZChjb2xvckRpdik7XHJcblxyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChjb2xvcik7XHJcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuXHJcblxyXG5cclxuICAgICAgICByb3cub25jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKEdpc3BsYXkucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9GYWRlID0gIWN1cnJlbnRhZXMuZW5hYmxlRGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvRmFkZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsKGN1cnJlbnRhZXMpO1xyXG4gICAgICAgICAgICBtYXBvYmouZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAoR2lzcGxheS5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkZSBmaWx0cmFnZW0gcGVsYSBsZWdlbmRhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRHcmFkaWVudChtYXBvYmosIGxlZnQsIG1pZGRsZSwgcmlnaHQpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCB2YWx1ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgIHZhbHVlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGxldCBudW1iZXJvZiA9IDU7XHJcbiAgICAgICAgaWYgKG1hcG9iai5hZXN0aGV0aWNzLmxlbmd0aCA+IDUpXHJcbiAgICAgICAgICAgIG51bWJlcm9mID0gbWFwb2JqLmFlc3RoZXRpY3MubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdHJjb2xvciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyb2Y7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG1hcG9iai5mY29sb3IoaSAvIG51bWJlcm9mKS5yZ2IoKTtcclxuICAgICAgICAgICAgc3RyY29sb3IgKz0gYCxyZ2JhKCR7TWF0aC5yb3VuZChjb2xvclswXSl9LCR7TWF0aC5yb3VuZChjb2xvclsxXSl9LCR7TWF0aC5yb3VuZChjb2xvclsyXSl9LCR7bWFwb2JqLmFscGhhfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJjb2xvciArPSAnKSAnO1xyXG4gICAgICAgIHZhbHVlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBgLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCR7c3RyY29sb3J9YDtcclxuXHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICB2YWx1ZURpdi5zdHlsZS53aWR0aCA9IDEzMDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgdmFsdWUyLmNvbFNwYW4gPSAyO1xyXG5cclxuICAgICAgICBjb25zdCBkaXZsZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgbGVmdHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWZ0KTtcclxuICAgICAgICBjb25zdCBkaXZtaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZtaWQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtaWRkbGUpO1xyXG4gICAgICAgIGNvbnN0IGRpdnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0dGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJpZ2h0KTtcclxuXHJcblxyXG5cclxuICAgICAgICBkaXZsZWZ0LmFwcGVuZENoaWxkKGxlZnR0ZXh0KTtcclxuICAgICAgICBkaXZtaWQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgZGl2cmlnaHQuYXBwZW5kQ2hpbGQocmlnaHR0ZXh0KTtcclxuICAgICAgICB2YWx1ZTIuYXBwZW5kQ2hpbGQoZGl2bGVmdCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdm1pZCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdnJpZ2h0KTtcclxuICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZCh2YWx1ZURpdik7XHJcbiAgICAgICAgcm93Mi5hcHBlbmRDaGlsZCh2YWx1ZTIpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93Mik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdChpZCwgY2xhc3NuYW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImlkID09IFwiICsgaWQpO1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApO1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaWYgKGNsYXNzbmFtZSAhPSB1bmRlZmluZWQgJiYgY2xhc3NuYW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5bGVnZW5kQlInO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZ2VuZERpdi5pZCA9IGBsZWdlbmREaXYke2lkfWA7XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLnRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICB0aGlzLnRhYmxlLnN0eWxlLnpJbmRleCA9IFwiMjAwMFwiO1xyXG4gICAgICAgIGNvbnN0IHRodmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIGNvbnN0IHRoY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIHRoY29sb3Iuc3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIC8vdGhjb2xvci5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRoY29sb3IpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdGl0bGVyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIHRpdGxldGQuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgdGl0bGV0ZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICB0aXRsZXRkLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGl0bGUpO1xyXG4gICAgICAgIHRpdGxldGQuYXBwZW5kQ2hpbGQodGl0bGV0ZXh0KTtcclxuICAgICAgICB0aXRsZXJvdy5hcHBlbmRDaGlsZCh0aXRsZXRkKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRpdGxlcm93KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyhjdXJyZW50YWVzLCBtYXBvYmosIG51bWJlcm9mKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdGRpdiA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgICAgICB2YWx1ZS5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgdGhpcy5maXJzdEluc2VydGlvbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHsgdGhpcy5maXJzdEluc2VydGlvbiA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwkezF9KWA7XHJcbiAgICAgICAgbGV0IHN0cm9rZWNvbG9yO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudGFlcy5zdHJva2VDb2xvciAhPSBudWxsICYmIGN1cnJlbnRhZXMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclswXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzFdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMl19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclszXX0pYDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0cm9rZWNvbG9yID0gYHJnYmEoJHswfSwkezB9LCR7MH0sJHsxfSlgO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gbnVtYmVyb2YgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGxldCBwcm9wdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0SW5zZXJ0aW9uID09IGZhbHNlICYmIGkgPT0gKG51bWJlcm9mIC0gMSkgfHwgbnVtYmVyb2YgPT0gMSlcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IGN1cnJlbnRhZXMucmFuZ2VbMV07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IG1hcG9iai5taW4gKyBpIC8gKG51bWJlcm9mIC0gMSkgKiAobWFwb2JqLm1heCAtIG1hcG9iai5taW4pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdW5kKHByb3B2YWx1ZSkpO1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJnYmM7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheXByb3BvcnRpb25hbGNpcmNsZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJvcmRlckNvbG9yID0gc3Ryb2tlY29sb3I7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBwb2ludHNpemUgPSAoKG1hcG9iai5tYXhwb2ludHNpemUgLSBtYXBvYmoubWlucG9pbnRzaXplKSAvIChtYXBvYmoubWF4IC0gbWFwb2JqLm1pbikpICogKHByb3B2YWx1ZSAtIG1hcG9iai5taW4pO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgodGVtcHBvaW50c2l6ZSwgNy41KTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5pbmhlcml0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb2xvckRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChHaXNwbGF5LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvRmFkZSA9ICFjdXJyZW50YWVzLmVuYWJsZURpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9GYWRlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbChjdXJyZW50YWVzKTtcclxuICAgICAgICAgICAgICAgIG1hcG9iai5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoR2lzcGxheS5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIGZpbHRyYWdlbSBwZWxhIGxlZ2VuZGEgKHNlZ3VuZG9zKTogJHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZSkgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuICAgICAgICAgICAgaWYgKC8qaSE9IChudW1iZXJvZi0xKSAmJiovIHRoaXMubGFzdGRpdiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdi5hcHBlbmRDaGlsZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdiA9IGNvbG9yRGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RkaXYgPSBjb2xvckRpdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RJbnNlcnRpb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0VTNlRlc3QvTGVnZW5kLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/ES6Test/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n    function BGMapWrapper(map) {\n        _classCallCheck(this, BGMapWrapper);\n\n        console.log(\"BGMapWrapper constructor?\");\n        this.map = map;\n        return this;\n    }\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.map.getContainer();\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.map.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //mapCanvas.style.zIndex = \"2\";\n\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.map.getZoom();\n        }\n    }, {\n        key: 'getLngBound',\n        value: function getLngBound() {\n            return this.map.getBounds().getNorthWest().lng;\n        }\n    }, {\n        key: 'getLatBound',\n        value: function getLatBound() {\n            return this.map.getBounds().getNorthWest().lat;\n        }\n    }, {\n        key: 'onEvent',\n        value: function onEvent(eventstr, eventfunction) {\n            this.map.on(eventstr, eventfunction);\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            if (this.loaderDiv === undefined) this.createLoader(this.map);else {\n                if (this.loaderDiv.style.display == 'none') this.loaderDiv.style.display = 'flex';else {\n                    this.loaderDiv.style.display = 'none';\n                }\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');\n                } else {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n                }\n            }\n        }\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n\n            /*outerDiv.style = ' opacity: 0.5; background-color: grey; justify-content: center; display: flex;';\r\n            outerDiv.style.position = 'absolute';\r\n            outerDiv.style.zIndex = '999999999';*/\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            this.loaderDiv = outerDiv;\n\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9NYXBzL0JHTWFwV3JhcHBlci5qcz9hZjNhIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5leHBvcnQgY2xhc3MgQkdNYXBXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQkdNYXBXcmFwcGVyIGNvbnN0cnVjdG9yP1wiKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldENvbnRhaW5lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcyhpZCkge1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIG1hcENhbnZhcy5pZCA9IGBtYXBDYW52YXMke2lkfWA7XHJcbiAgICAgICAgbWFwQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHJcbiAgICAgICAgY29uc3QgbWFwRGl2ID0gdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgbWFwQ2FudmFzLmhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgbWFwQ2FudmFzLndpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIC8vbWFwQ2FudmFzLnN0eWxlLnpJbmRleCA9IFwiMlwiO1xyXG5cclxuICAgICAgICAvL2Nhc2UgbWFwYm94XHJcbiAgICAgICAgbWFwRGl2Lmluc2VydEJlZm9yZShtYXBDYW52YXMsIG1hcERpdi5maXJzdENoaWxkLm5leHRTaWJsaW5nKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7aWR9YCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TG5nQm91bmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxuZztcclxuICAgIH1cclxuXHJcbiAgICBnZXRMYXRCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkubGF0O1xyXG4gICAgfVxyXG5cclxuICAgIG9uRXZlbnQoZXZlbnRzdHIsIGV2ZW50ZnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLm1hcC5vbihldmVudHN0ciwgZXZlbnRmdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRlckRpdiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUxvYWRlcih0aGlzLm1hcCk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlckRpdi5zdHlsZS5kaXNwbGF5ID09ICdub25lJylcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5pbmNsdWRlcygnX2dpc3BsYXloaWRkZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lID0gdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5aGlkZGVuKD8hXFxTKS9nLCAnX2dpc3BsYXlMb2FkZXJPdXRlckRpdicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lID0gdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5TG9hZGVyT3V0ZXJEaXYoPyFcXFMpL2csICdfZ2lzcGxheWhpZGRlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUxvYWRlcigpIHtcclxuICAgICAgICBjb25zdCBvdXRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbnN0IGlubmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaW5uZXJEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5bG9hZGVyJztcclxuXHJcbiAgICAgICAgY29uc3QgbWFwRGl2ID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuXHJcbiAgICAgICAgLypvdXRlckRpdi5zdHlsZSA9ICcgb3BhY2l0eTogMC41OyBiYWNrZ3JvdW5kLWNvbG9yOiBncmV5OyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgZGlzcGxheTogZmxleDsnO1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS56SW5kZXggPSAnOTk5OTk5OTk5JzsqL1xyXG4gICAgICAgIG91dGVyRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheUxvYWRlck91dGVyRGl2JztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS5oZWlnaHQgPSBtYXBEaXYub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLndpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIG91dGVyRGl2LmFwcGVuZENoaWxkKGlubmVyRGl2KTtcclxuICAgICAgICB0aGlzLmxvYWRlckRpdiA9IG91dGVyRGl2O1xyXG5cclxuICAgICAgICBtYXBEaXYucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUob3V0ZXJEaXYsIG1hcERpdik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9FUzZUZXN0L01hcHMvQkdNYXBXcmFwcGVyLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/ES6Test/Maps/Choropleth.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 6);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    function Choropleth(bgmap, geometry, options) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, options));\n\n        _this.aesthetics = new Array();\n        _this.geometry = geometry;\n        _this.loadOptions(options, bgmap);\n        _this.id = 0; //mapcount++;\n        _this.type = 'CP';\n        maps.push(_this);\n        _this.initialize();\n        /*return this;*/\n        return _this;\n    }\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            //console.log(\"Choropleth drawaaa() called\");\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawTriangles(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            //console.log(\"Choropleth buildLegend() called\");\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPolygonRow(this.aesthetics[a], this);\n            }\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            //console.log(\"Choropleth defaults() called\");\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9NYXBzL0Nob3JvcGxldGguanM/MGRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSAnLi4vTGVnZW5kJztcclxuXHJcbi8qKlxyXG4gKiBDaG9yb3BsZXRoIGltcGxlbWVudGF0aW9uIDA2LzAzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9wbGV0aCBleHRlbmRzIE1hcCB7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSAwOy8vbWFwY291bnQrKztcclxuICAgICAgICB0aGlzLnR5cGUgPSAnQ1AnO1xyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAvKnJldHVybiB0aGlzOyovXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBkcmF3YWFhKCkgY2FsbGVkXCIpO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VHJpYW5nbGVzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBidWlsZExlZ2VuZCgpIGNhbGxlZFwiKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhIGluIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2x5Z29uUm93KHRoaXMuYWVzdGhldGljc1thXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNob3JvcGxldGggZGVmYXVsdHMoKSBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3doaXRlJywgJ3llbGxvdycsICdvcmFuZ2UnLCAncmVkJ107XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWJlck9mQ2xhc3NlcyA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvRVM2VGVzdC9NYXBzL0Nob3JvcGxldGguanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/ES6Test/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n/*import rbush from '../../lib/rtree';*/\n\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 4);\n\nvar _chroma = __webpack_require__(/*! ../../lib/chroma.min */ 7);\n\nvar _chroma2 = _interopRequireDefault(_chroma);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 1);\n\nvar _earcut = __webpack_require__(/*! ../../lib/earcut */ 8);\n\nvar _earcut2 = _interopRequireDefault(_earcut);\n\nvar _rtree = __webpack_require__(/*! ../../lib/rtree */ 9);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available.\r\n */\nvar Map = exports.Map = function () {\n    function Map(type, geometry, options) {\n        _classCallCheck(this, Map);\n\n        console.log(\"Map constructor called -> super()\");\n        /* return this;*/ //@TODO Remove isnt doing anything? or is it saving the 3 parameters?\n    }\n\n    _createClass(Map, [{\n        key: 'program',\n        value: function program() {\n            this._webgl.program = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram = [];\n            this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();\n\n            var source_code = this.generateShaders();\n\n            var vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);\n            var fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);\n\n            this._webgl.gl.attachShader(this._webgl.program, vertex_shader);\n            this._webgl.gl.attachShader(this._webgl.program, fragment_shader);\n\n            this._webgl.gl.linkProgram(this._webgl.program);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'shader',\n        value: function shader(type, source_code, _webgl) {\n            //Added HERE by Rui\n            var shader = _webgl.gl.createShader(type);\n\n            _webgl.gl.shaderSource(shader, source_code);\n            _webgl.gl.compileShader(shader);\n\n            console.log(\"shader \" + (type.valueOf() == 35633 ? \"vertex\" : \"fragment\") + \": \" + _webgl.gl.getShaderInfoLog(shader));\n\n            return shader;\n        }\n    }, {\n        key: 'generateShaders',\n        value: function generateShaders() {\n            //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=\n            //general\n\n            var vertexSourceCode = \" attribute vec4 vertexCoord; \";\n            vertexSourceCode += \"\\n\tattribute float aPointSize; \";\n            vertexSourceCode += \"\\n\tuniform mat4 projection; \";\n            vertexSourceCode += \"\\n\tattribute float a_opacity; \";\n            vertexSourceCode += \"\\n\tvarying float v_opacity; \";\n            //vertexSourceCode+= \"\\n\tvarying vec4 u_color; \" ; //delete\n            vertexSourceCode += \"\\n\tvoid main() {\";\n            vertexSourceCode += \"\\n\t\tgl_Position = (projection * vertexCoord); \";\n            vertexSourceCode += \"\\n\t\tgl_PointSize = aPointSize; v_opacity = a_opacity; \";\n            vertexSourceCode += \"\\n}\";\n\n            var fragmentSourceCode = \"precision mediump float;\";\n            fragmentSourceCode += \"\\n\t\tuniform vec4 u_color;\"; //uniform\n            fragmentSourceCode += \"\\n\t\tvarying float v_opacity; \";\n            fragmentSourceCode += \"\\n \t\tuniform float isPoint;\";\n            fragmentSourceCode += \"\\n\t\tvoid main(){\";\n            fragmentSourceCode += \"\\n\t\t\tfloat border = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat radius = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat centerDist = length(gl_PointCoord - 0.5);\";\n            fragmentSourceCode += \"\\n\t\t\tfloat alpha;\";\n            fragmentSourceCode += \"\\n\t\t\tif (u_color[3] == -1.0){\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  v_opacity * step(centerDist, radius);\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\telse{\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  u_color[3] * step(centerDist, radius);\";\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\tif(isPoint == 1.0 ){\";\n            fragmentSourceCode += \"\\n\t\t\tif (alpha < 0.1) discard;\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}\";\n            fragmentSourceCode += \"\\n \t\t\telse\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\";\n            fragmentSourceCode += \"\\n\t\t}\";\n\n            return { vertex: vertexSourceCode, fragment: fragmentSourceCode };\n        }\n    }, {\n        key: 'addAesthetic',\n        value: function addAesthetic(aes) {\n            this.aesthetics.push(aes);\n        }\n    }, {\n        key: 'setAesthetic',\n        value: function setAesthetic(id, aes) {\n            for (var i = 0; i < aesthetics.length; i++) {\n                if (id == aesthetics[i].id) {\n                    aesthetics[i] = aes;\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            //legendDiv.style.height = 200;//(mapCanvas.height / 10);\n            legendDiv.style.width = 250; //(mapCanvas.width / 10);\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            //thvalue.style.width = 125;\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var currentaes = _step.value;\n\n                    //if(currentaes._features.length > 0 || currentaes._allFeatures.length > 0){\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    //console.log(rgbc);\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                    colorDiv.style.width = 80; //(mapCanvas.width / 10);\n\n\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n\n                    table.appendChild(row);\n                    //}\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.map.getContainer().appendChild(legendDiv);\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n\n            var aesarray = [];\n            var values = [];\n            var strings = [];\n            var breaks = void 0;\n            var fcolor = void 0;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (geojson.features[g].properties[this.attr] != null && typeof geojson.features[g].properties[this.attr] == 'number') {\n                    values.push(geojson.features[g].properties[this.attr]);\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);\n                } else if (!strings.includes(geojson.features[g].properties[this.attr])) strings.push(geojson.features[g].properties[this.attr]);\n            }\n            if (values.length > 0) {\n                //quantitative\n                if (this.breaks == undefined) {\n                    if (numberOf > 1) breaks = this.calcClassBreaks(values, algorithm, numberOf);else breaks = [this.min, this.max];\n                } else {\n                    breaks = this.breaks;\n                }\n                if (breaks.length > 2) {\n                    fcolor = _chroma2.default.scale(colorscheme).colors(breaks.length - 1);\n                    for (var i = 0; i < breaks.length - 1; i++) {\n                        var color = (0, _chroma2.default)(fcolor[i]).rgb();\n                        if (i != breaks.length - 2) {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                        } else {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    color = (0, _chroma2.default)(colorscheme[0]).rgb();\n                    var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n                    aes.outer = true;\n                    aesarray.push(aes);\n                }\n            } else {\n                //qualitative\n                if (strings.length > 0) {\n                    breaks = strings;\n                    if (typeof colorscheme === 'string') {\n                        //string\n                        fcolor = _chroma2.default.scale(colorscheme).colors(breaks.length);\n                    } else {\n                        //array\n                        fcolor = _chroma2.default.scale(colorscheme).colors(breaks.length);\n                    }\n                    for (var i = 0; i < breaks.length; i++) {\n                        var color = (0, _chroma2.default)(fcolor[i]).rgb();\n                        var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);\n                        aesarray.push(aes);\n                    }\n                }\n            }\n\n            this.aesthetics = aesarray;\n            //return aesarray;\n\n        }\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(values, algorithm, numberOf) {\n            var breaks = void 0;\n            switch (algorithm) {\n                case 'equidistant':\n                    breaks = _chroma2.default.limits(values, 'e', numberOf);\n                    break;\n\n                case 'quantile':\n                    breaks = _chroma2.default.limits(values, 'q', numberOf);\n                    break;\n\n                case 'k-means':\n                    breaks = _chroma2.default.limits(values, 'k', numberOf);\n                    break;\n\n                default:\n                    breaks = _chroma2.default.limits(values, 'q', numberOf);\n                    break;\n            }\n            return breaks;\n        }\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var flag = false;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {\n                    this.aesthetics[i].addFeature(id, properties, triangles, borders, points);\n                    flag = true;\n                }\n            }\n            if (!flag) {\n                //TODO\n                //console.log(\"TODO: feature does not fit into any of the aesthetics defined.\\n Value: \" + properties[this.attr]);\n            }\n        }\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(idaes, triangles, borders, points) {\n\n            this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);\n        }\n    }, {\n        key: 'draw',\n        value: function draw() {\n\n            alert(\"draw() not implemented\");\n        }\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n\n            if (polygon.geometry.type == \"Polygon\") {\n                var outsidepolygon = polygon.geometry.coordinates[0];\n\n                var insidepolygons = [];\n                for (var k = 1; k < polygon.geometry.coordinates.length; k++) {\n                    //todo inside polygon\n                    //insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                }\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                    _vertexcount += (outsidepolygon.length + 1) / 2;\n                    //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                }\n\n                var triangles_vert = (0, _earcut2.default)(tempVerts);\n                _tricount += triangles_vert.length / 3;\n                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                var polyarray = [];\n                for (var i = 0; i < polygon.geometry.coordinates.length; i++) {\n\n                    var outsidepolygon = polygon.geometry.coordinates[i][0];\n\n                    var insidepolygons = [];\n                    for (var k = 1; k < polygon.geometry.coordinates[i].length; k++) {\n                        //todo inside polygon\n                        insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                    }\n                    var tempVerts = new Array();\n                    _vertexcount += outsidepolygon.length;\n                    for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                        tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n\n                        //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                    }\n\n                    var triangles_vert = (0, _earcut2.default)(tempVerts);\n\n                    //var temp = earcut.flatten(polygon.geometry.coordinates[i]);\n                    //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);\n                    _tricount += triangles_vert.length / 3;\n                    polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n                    //console.log(polyarray);\n                }\n\n                return polyarray;\n            }\n        }\n    }, {\n        key: 'processData',\n        value: function processData(geojson) {\n\n            this.loadGeoJSON(geojson);\n        }\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(id, geometry, properties) {\n            var gl = this._webgl.gl;\n            if (this.minuend != undefined && this.subtrahend != undefined && typeof properties[this.minuend] == 'number' && properties[this.subtrahend] != undefined && typeof properties[this.subtrahend] == 'number' && properties[this.subtrahend] != undefined) {\n                properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];\n            }\n\n            if (geometry.type == \"Polygon\" || geometry.type == \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentBorders = [];\n                var currentTriangles = [];\n                var bufferT = [];\n                var bufferB = [];\n\n                for (var j = 0; j < polygons.length; j++) {\n                    var trianglespolygon = polygons[j].triangles;\n                    var border = polygons[j].vertex;\n                    currentTriangles[j] = new Array();\n                    currentBorders[j] = new Array();\n                    for (var h = 0; h < trianglespolygon.length; h++) {\n                        var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);\n                        currentTriangles[j].push(pixel.x, pixel.y);\n\n                        if (h == trianglespolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[j].itemSize = 2;\n                            bufferT[j].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var y = 0; y < border.length; y += 2) {\n                        var pixel = this.latLongToPixelXY(border[y], border[y + 1]);\n                        currentBorders[j].push(pixel.x, pixel.y);\n\n                        if (y == border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentBorders[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferB[j].itemSize = 2;\n                            bufferB[j].numItems = vertArray.length / 2;\n                        }\n                    }\n                }\n                //polygon\n                this.insertFeature(id, properties, bufferT, bufferB, []);\n            } else if (geometry.type == \"Point\" && this.dynamic == true) {\n                //dum\n                var currentPoints = [];\n                currentPoints[0] = new Array();\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                currentPoints[0].push(pixel.x, pixel.y);\n                var bufferP = [];\n                bufferP.push(gl.createBuffer());\n\n                var vertArray = new Float32Array(currentPoints[0]);\n\n                gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                bufferP[0].itemSize = 2;\n                bufferP[0].numItems = vertArray.length / 2;\n\n                this.insertFeature(id, properties, [], [], bufferP);\n\n                if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type == \"Point\" && this.dynamic == false) {\n                //debugger;\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                if (this.tempPoints == null || this.tempPoints == undefined) {\n                    this.tempPoints = new Array();\n                    for (var a = 0; a < this.aesthetics.length; a++) {\n                        this.tempPoints[a] = [];\n                    }\n                }\n\n                var aesarrays = this.fitFeature(properties);\n                for (var y = 0; y < aesarrays.length; y++) {\n                    this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);\n                }\n\n                if (this.treepoints == null) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempPoints != null) {\n                for (var t = 0; t < this.tempPoints.length; t++) {\n                    if (this.tempPoints[t].length > 0) {\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        var vertArray = new Float32Array(this.tempPoints[t]);\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(t, [], [], bufferP);\n                    }\n                }\n            }\n            //console.log(geojson)\n            if (this.treepoints != null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons == true)\n                //this.rtree = new PolygonLookup(geojson);\n                console.log(\"@Rui LOOK I WAS REMOVED\");\n        }\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                geojson.features[g].properties['_gisplayid'] = g;\n                var geometry = geojson.features[g].geometry;\n                var properties = geojson.features[g].properties;\n                this.createAndInsertFeature(g, geometry, properties);\n            }\n            this.buildTrees(geojson);\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.map.createCanvas(this.id);\n\n            //init webgl properties\n            this._webgl = {\n                gl: null,\n                program: null,\n                projection: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            this._webgl.projection = new Float32Array(16);\n            this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n            this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'getNumberOfFeatures',\n        value: function getNumberOfFeatures() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                count += this.aesthetics[i]._features.length;\n            }\n            return count;\n        }\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            // scaling x and y, which is just scaling first two rows of matrix\n            matrix[0] *= scaleX;\n            matrix[1] *= scaleX;\n            matrix[2] *= scaleX;\n            matrix[3] *= scaleX;\n\n            matrix[4] *= scaleY;\n            matrix[5] *= scaleY;\n            matrix[6] *= scaleY;\n            matrix[7] *= scaleY;\n        }\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            // translation is in last row of matrix\n            matrix[12] += matrix[0] * tx + matrix[4] * ty;\n            matrix[13] += matrix[1] * tx + matrix[5] * ty;\n            matrix[14] += matrix[2] * tx + matrix[6] * ty;\n            matrix[15] += matrix[3] * tx + matrix[7] * ty;\n        }\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n\n            return pixel;\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._borders.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length && this.dynamic == true; i++) {\n                for (var y = 0; y < aes._features[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                    //1);\n                }\n            }\n\n            for (var i = 0; this.dynamic == false && aes._allFeatures != null && i < aes._allFeatures.length; i++) {\n                for (var y = 0; y < aes._allFeatures[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);\n                    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);\t\n                    //1);\n                }\n            }\n        }\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n\n            for (var i = 0; i < aes._features.length; i++) {\n                var ucolor = void 0;\n                var color = void 0;\n                var diff = aes._features[i]._properties[this.attr];\n                if (diff == 0) color = aes.fillColor(0.5).rgb();else {\n                    if (diff > 0) {\n                        color = aes.fillColor(0.5 + diff / this.max / 2).rgb();\n                    } else {\n                        color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                }\n                ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];\n\n                gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawProporcionalPoints',\n        value: function drawProporcionalPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);\n\n            if (this.dynamic == true) {\n                for (var i in aes._features) {\n                    for (var y in aes._features[i]._points) {\n\n                        gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n                        var propvalue = parseFloat(aes._features[i]._properties[this.attr]);\n                        var temppointsize = (this.maxpointsize - this.minpointsize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n                        var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n                        gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n                        gl.enableVertexAttribArray(vertexCoordLocation);\n                        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                        //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                        //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                        gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                        //1);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            this.max = null;\n            this.min = null;\n            this.createCanvas();\n            this.program();\n            var mappos = void 0;\n            for (var i = 0; i < maps.length; i++) {\n                if (maps[i].id == this.id) mappos = i;\n            }this.map.onEvent('move', function () {\n                console.log(\"@Rui: mudar o profiling do window para outra coisa?\");\n                if (window.profiling == true) var start = Date.now();\n                maps[mappos].draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de Zoom/Pan (segundos):' + (end - start) / 1000);\n                }\n            });\n\n            this.setupOnclick(mappos);\n        }\n    }, {\n        key: 'setupOnclick',\n        value: function setupOnclick(mappos) {\n            console.log(\"@Rui: profiling mudar de window para? | Rtree e KdTree\");\n            maps[mappos].map.onEvent('click', function (e) {\n                if (window.profiling == true) var start = Date.now();\n                var lat = e.latlng.lat;\n                var lon = e.latlng.lng;\n\n                if (maps[mappos].rtree != undefined) {\n                    var bool = maps[0].rtree.search(lon, lat);\n                    if (bool == undefined) return;else {\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s); //todo\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n                if (maps[mappos].kdtree != undefined) {\n\n                    var nearest = maps[mappos].kdtree.nearest({ lat: lat, lon: lon }, 1, 128 / 2 ** (map.getZoom() * 2));\n                    if (nearest.length <= 0) return;else {\n                        var bool = nearest[0][0];\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s);\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de um click (segundos): ' + (end - start) / 1000);\n                }\n            });\n        }\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var result = [];\n            for (var a = 0; a < this.aesthetics.length; a++) {\n                if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true) result.push(a);\n            }\n            return result;\n        }\n    }, {\n        key: 'loadOptions',\n        value: function loadOptions(options, bgmap) {\n            if (options.customMapService == true) this.map = bgmap;else this.map = new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (options.loader != false) this.loader();\n\n            if (options.showPropertiesOnClick == true) {\n                this.showPropertiesOnClick = null;\n                //append on bgmap object\n            } else if (options.showPropertiesOnClick == false) {\n                //nada\n            } else if (options.showPropertiesOnClick != undefined) {\n                this.showPropertiesOnClick = options.showPropertiesOnClick;\n            }\n            this.alpha = options.alpha != undefined ? options.alpha : 0.8;\n            this.interactive = options.interactive == undefined ? true : !options.interactive;\n            this.attr = options.attr;\n            this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;\n            this.maxfeatures = options.maxFeatures;\n            this.breaks = options.classBreaks;\n            this.colorscheme = options.colorScheme;\n            this.numberofclasses = options.numberOfClasses;\n            this.algorithm = options.classBreaksMethod;\n            this.legendOnClickCall = options.legendOnClickFunction;\n            this.mapOnClickCall = options.mapOnClickFunction;\n            this.minuend = options.minuend;\n            this.subtrahend = options.subtrahend;\n            this.legendTitle = options.legendTitle != undefined ? options.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n            this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            this.map.loader();\n        }\n    }, {\n        key: 'drawHeatPoints',\n        value: function drawHeatPoints(aes) {\n            var gl = this._webgl.gl;\n\n            if (gl == null) return;\n            gl.useProgram(this._webgl.heatmapProgram[0]);\n            var matrixProjection = new Float32Array(16);\n\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n\n            gl.blendFunc(gl.ONE, gl.ONE);\n\n            var currentZoom = map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'position');\n            var deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'delta');\n            var intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'intensity');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'aPointSize');\n\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            gl.enableVertexAttribArray(vertexCoordLocation);\n            gl.enableVertexAttribArray(deltaLocation);\n            gl.enableVertexAttribArray(intensityLoc);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);\n            gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);\n            gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);\n            gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);\n\n            console.log(aes._allFeatures[0]._points[0].numItems);\n            gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);\n\n            gl.useProgram(this._webgl.heatmapProgram[1]);\n\n            gl.disable(gl.BLEND);\n\n            //console.log(\"fase 1 concluida\");\n\n            var canvas = document.getElementById('mapCanvas' + this.id);\n\n            var source = gl.createTexture();\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, source);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n\n            function isPowerOf2(value) {\n                return (value & value - 1) == 0;\n            };\n\n            function steupTextureFilteringAndMips(width, height, gl) {\n                if (isPowerOf2(width) && isPowerOf2(height)) {\n                    // the dimensions are power of 2 so generate mips and turn on \n                    // tri-linear filtering.\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                } else {\n                    // at least one of the dimensions is not a power of 2 so set the filtering\n                    // so WebGL will render it.\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n            };\n\n            steupTextureFilteringAndMips(canvas.width, canvas.height, gl);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            var vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n            var buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            var positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], 'position');\n            var sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], 'source');\n            gl.enableVertexAttribArray(positionLoc);\n            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.uniform1i(sourceLoc, 0);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            gl.disableVertexAttribArray(positionLoc);\n            //defaults to general program\n            //console.log(\"fase 2 concluida\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'getNumberOfPolygons',\n        value: function getNumberOfPolygons() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                for (var z = 0; z < this.aesthetics[i]._features.length; z++) {\n                    count += this.aesthetics[i]._features[z]._triangles.length;\n                }\n            }\n            return count;\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvRVM2VGVzdC9NYXBzL01hcC5qcz8wZjg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QkdNYXBXcmFwcGVyfSBmcm9tICcuL0JHTWFwV3JhcHBlcic7XHJcbmltcG9ydCBjaHJvbWEgZnJvbSAnLi4vLi4vbGliL2Nocm9tYS5taW4nO1xyXG5pbXBvcnQge0Flc3RoZXRpY30gZnJvbSAnLi4vQWVzdGhldGljJztcclxuaW1wb3J0IGVhcmN1dCBmcm9tICcuLi8uLi9saWIvZWFyY3V0J1xyXG5cclxuLyppbXBvcnQgcmJ1c2ggZnJvbSAnLi4vLi4vbGliL3J0cmVlJzsqL1xyXG5pbXBvcnQge1BvbHlnb25Mb29rdXB9IGZyb20gJy4uLy4uL2xpYi9ydHJlZSc7XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHRoZSBNYXAgY2xhc3Mgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBtYXAuXHJcbiAqIEVhY2ggbWFwIGhhcyBhIGdyb3VwIG9mIGZ1bmN0aW9ucyBhdmFpbGFibGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgY29uc29sZS5sb2coXCJNYXAgY29uc3RydWN0b3IgY2FsbGVkIC0+IHN1cGVyKClcIilcclxuICAgICAgIC8qIHJldHVybiB0aGlzOyovIC8vQFRPRE8gUmVtb3ZlIGlzbnQgZG9pbmcgYW55dGhpbmc/IG9yIGlzIGl0IHNhdmluZyB0aGUgMyBwYXJhbWV0ZXJzP1xyXG4gICAgfVxyXG5cclxuICAgIHByb2dyYW0oKSB7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wucHJvZ3JhbSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdID0gdGhpcy5fd2ViZ2wuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzFdID0gdGhpcy5fd2ViZ2wuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2VfY29kZSA9IHRoaXMuZ2VuZXJhdGVTaGFkZXJzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleF9zaGFkZXIgPSB0aGlzLnNoYWRlcih0aGlzLl93ZWJnbC5nbC5WRVJURVhfU0hBREVSLCBzb3VyY2VfY29kZS52ZXJ0ZXgsIHRoaXMuX3dlYmdsKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudF9zaGFkZXIgPSB0aGlzLnNoYWRlcih0aGlzLl93ZWJnbC5nbC5GUkFHTUVOVF9TSEFERVIsIHNvdXJjZV9jb2RlLmZyYWdtZW50LCB0aGlzLl93ZWJnbCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmF0dGFjaFNoYWRlcih0aGlzLl93ZWJnbC5wcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5hdHRhY2hTaGFkZXIodGhpcy5fd2ViZ2wucHJvZ3JhbSwgZnJhZ21lbnRfc2hhZGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wubGlua1Byb2dyYW0odGhpcy5fd2ViZ2wucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5wcm9ncmFtKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNoYWRlcih0eXBlLCBzb3VyY2VfY29kZSwgX3dlYmdsKSB7IC8vQWRkZWQgSEVSRSBieSBSdWlcclxuICAgICAgICB2YXIgc2hhZGVyID0gX3dlYmdsLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuXHJcbiAgICAgICAgX3dlYmdsLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZV9jb2RlKTtcclxuICAgICAgICBfd2ViZ2wuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcInNoYWRlciBcIiArICh0eXBlLnZhbHVlT2YoKSA9PSAzNTYzMyA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIpICsgXCI6IFwiICsgX3dlYmdsLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVTaGFkZXJzKCkgeyAvL0FkZGVkIEhFUkUgYnkgUnVpIEBUT0RPIFJlZmFjdG9yIHRvIHVzZSBFUzYgYGAgaW5zdGVhZCBvZiArPVxyXG4gICAgICAgIC8vZ2VuZXJhbFxyXG5cclxuICAgICAgICBsZXQgdmVydGV4U291cmNlQ29kZSA9IFwiIGF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvb3JkOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRhdHRyaWJ1dGUgZmxvYXQgYVBvaW50U2l6ZTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb247IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdGF0dHJpYnV0ZSBmbG9hdCBhX29wYWNpdHk7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdHZhcnlpbmcgZmxvYXQgdl9vcGFjaXR5OyBcIjtcclxuICAgICAgICAvL3ZlcnRleFNvdXJjZUNvZGUrPSBcIlxcblx0dmFyeWluZyB2ZWM0IHVfY29sb3I7IFwiIDsgLy9kZWxldGVcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHR2b2lkIG1haW4oKSB7XCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0XHRnbF9Qb3NpdGlvbiA9IChwcm9qZWN0aW9uICogdmVydGV4Q29vcmQpOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRcdGdsX1BvaW50U2l6ZSA9IGFQb2ludFNpemU7IHZfb3BhY2l0eSA9IGFfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcbn1cIjtcclxuXHJcbiAgICAgICAgbGV0IGZyYWdtZW50U291cmNlQ29kZSA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1wiOy8vdW5pZm9ybVxyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR2YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuIFx0XHR1bmlmb3JtIGZsb2F0IGlzUG9pbnQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHZvaWQgbWFpbigpe1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGZsb2F0IGJvcmRlciA9IDAuNTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCByYWRpdXMgPSAwLjU7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgY2VudGVyRGlzdCA9IGxlbmd0aChnbF9Qb2ludENvb3JkIC0gMC41KTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCBhbHBoYTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRpZiAodV9jb2xvclszXSA9PSAtMS4wKXtcIjsgICAvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHZfb3BhY2l0eSAqIHN0ZXAoY2VudGVyRGlzdCwgcmFkaXVzKTtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHR9XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZWxzZXtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHVfY29sb3JbM10gKiBzdGVwKGNlbnRlckRpc3QsIHJhZGl1cyk7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0fVwiOy8vdW5uZWNlc3Nhcnk/P1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGlmKGlzUG9pbnQgPT0gMS4wICl7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0aWYgKGFscGhhIDwgMC4xKSBkaXNjYXJkO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yWzBdLCB1X2NvbG9yWzFdLCB1X2NvbG9yWzJdLCBhbHBoYSk7fVwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcbiBcdFx0XHRlbHNlXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3JbMF0sIHVfY29sb3JbMV0sIHVfY29sb3JbMl0sIHVfY29sb3JbM10pO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR9XCI7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHZlcnRleDogdmVydGV4U291cmNlQ29kZSwgZnJhZ21lbnQ6IGZyYWdtZW50U291cmNlQ29kZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEFlc3RoZXRpYyhhZXMpIHtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MucHVzaChhZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEFlc3RoZXRpYyhpZCwgYWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCA9PSBhZXN0aGV0aWNzW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZXN0aGV0aWNzW2ldID0gYWVzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7dGhpcy5pZH1gKTtcclxuICAgICAgICBjb25zdCBsZWdlbmREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBsZWdlbmREaXYuaWQgPSBgbGVnZW5kRGl2JHt0aGlzLmlkfWA7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAvL2xlZ2VuZERpdi5zdHlsZS5oZWlnaHQgPSAyMDA7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUud2lkdGggPSAyNTA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3R0b20gPSAyMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJvcmRlciA9ICdzb2xpZCc7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XHJcbiAgICAgICAgY29uc3QgdGh2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgY29uc3QgdGhjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgLy90aHZhbHVlLnN0eWxlLndpZHRoID0gMTI1O1xyXG4gICAgICAgIHRhYmxlLnN0eWxlLnpJbmRleCA9IFwiMjAwMFwiO1xyXG4gICAgICAgIHRoY29sb3Iuc3R5bGUud2lkdGggPSAxMDA7XHJcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGhjb2xvcik7XHJcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGh2YWx1ZSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRhZXMgb2YgdGhpcy5hZXN0aGV0aWNzKSB7XHJcbiAgICAgICAgICAgIC8vaWYoY3VycmVudGFlcy5fZmVhdHVyZXMubGVuZ3RoID4gMCB8fCBjdXJyZW50YWVzLl9hbGxGZWF0dXJlcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgICAgICAgICBsZXQgdGV4dDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50YWVzLnJhbmdlWzBdID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgWyR7Y3VycmVudGFlcy5yYW5nZVswXX0sICR7Y3VycmVudGFlcy5yYW5nZVsxXX1bYCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjdXJyZW50YWVzLnJhbmdlWzBdKTtcclxuICAgICAgICAgICAgcHRleHQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHB0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgY29uc3QgcmdiYyA9IGByZ2JhKCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMF19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMV19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMl19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbM119KWA7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmdiYyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSA9IHJnYmM7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IDI1Oy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gODA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBjb2xvci5hcHBlbmRDaGlsZChjb2xvckRpdik7XHJcblxyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY29sb3IpO1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZWdlbmREaXYuYXBwZW5kQ2hpbGQodGFibGUpO1xyXG4gICAgICAgIHRoaXMubWFwLmdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKGxlZ2VuZERpdik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJlUHJvY2Vzc0RhdGEoZ2VvanNvbiwgbnVtYmVyT2YsIGFsZ29yaXRobSwgY29sb3JzY2hlbWUpIHtcclxuXHJcbiAgICAgICAgY29uc3QgYWVzYXJyYXkgPSBbXTtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBzdHJpbmdzID0gW107XHJcbiAgICAgICAgbGV0IGJyZWFrcztcclxuICAgICAgICBsZXQgZmNvbG9yO1xyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggJiYgKHRoaXMubWF4ZmVhdHVyZXMgPT0gdW5kZWZpbmVkIHx8IGcgPCB0aGlzLm1heGZlYXR1cmVzKTsgZysrKSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSAhPSBudWxsICYmIHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGlmICghc3RyaW5ncy5pbmNsdWRlcyhnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7Ly9xdWFudGl0YXRpdmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnJlYWtzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlck9mID4gMSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha3MgPSB0aGlzLmNhbGNDbGFzc0JyZWFrcyh2YWx1ZXMsIGFsZ29yaXRobSwgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gdGhpcy5icmVha3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJyZWFrcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhicmVha3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyZWFrcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSBicmVha3MubGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzW2ldLCBicmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzW2ldLCBicmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFlcy5vdXRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY2hyb21hKGNvbG9yc2NoZW1lWzBdKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbMF0sIGJyZWFrc1sxXV0pO1xyXG4gICAgICAgICAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgZWxzZSB7Ly9xdWFsaXRhdGl2ZVxyXG4gICAgICAgICAgICBpZiAoc3RyaW5ncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBzdHJpbmdzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvcnNjaGVtZSA9PT0gJ3N0cmluZycpIHsvL3N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhicmVha3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYWtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY2hyb21hKGZjb2xvcltpXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgMV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW3N0cmluZ3NbaV1dKTtcclxuICAgICAgICAgICAgICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgICAgIC8vcmV0dXJuIGFlc2FycmF5O1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY2FsY0NsYXNzQnJlYWtzKHZhbHVlcywgYWxnb3JpdGhtLCBudW1iZXJPZikge1xyXG4gICAgICAgIGxldCBicmVha3M7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0pIHtcclxuICAgICAgICAgICAgY2FzZSAnZXF1aWRpc3RhbnQnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdlJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBjaHJvbWEubGltaXRzKHZhbHVlcywgJ3EnLCBudW1iZXJPZik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2stbWVhbnMnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdrJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdxJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicmVha3M7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uY2hlY2tQcm9wZXJ0eShwcm9wZXJ0aWVzW3RoaXMuYWVzdGhldGljc1tpXS5nZXRBdHRyKCldKSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFlc3RoZXRpY3NbaV0uYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbGFnKSB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ETzogZmVhdHVyZSBkb2VzIG5vdCBmaXQgaW50byBhbnkgb2YgdGhlIGFlc3RoZXRpY3MgZGVmaW5lZC5cXG4gVmFsdWU6IFwiICsgcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0R3JvdXBlZEZlYXR1cmUoaWRhZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljc1tpZGFlc10uYWRkR3JvdXBlZEZlYXR1cmUobnVsbCwgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG5cclxuICAgICAgICBhbGVydChcImRyYXcoKSBub3QgaW1wbGVtZW50ZWRcIik7XHJcblxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc1BvbHlnb24ocG9seWdvbikge1xyXG5cclxuICAgICAgICBpZiAocG9seWdvbi5nZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5zaWRlcG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgIC8vaW5zaWRlcG9seWdvbnMucHVzaChwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcFZlcnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChvdXRzaWRlcG9seWdvbltvdXRdWzBdLCBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXhjb3VudCArPSAob3V0c2lkZXBvbHlnb24ubGVuZ3RoICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvbjogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzBdICsgXCIgbGF0OiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG4gICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICBwb2x5YXJyYXkucHVzaCh7IHRyaWFuZ2xlczogdHJpYW5nbGVzX3ZlcnQsIHZlcnRleDogdGVtcFZlcnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBlbHNlIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB2YXIgcG9seWFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1bMF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZXBvbHlnb25zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBpbnNpZGVwb2x5Z29ucy5wdXNoKHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1ba10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBWZXJ0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgX3ZlcnRleGNvdW50ICs9IG91dHNpZGVwb2x5Z29uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRzLnB1c2gob3V0c2lkZXBvbHlnb25bb3V0XVswXSwgb3V0c2lkZXBvbHlnb25bb3V0XVsxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJsb246IFwiICsgb3V0c2lkZXBvbHlnb25bb3V0XVswXSArIFwiIGxhdDogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFyIHRlbXAgPSBlYXJjdXQuZmxhdHRlbihwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHRyaWFuZ2xlc192ZXJ0ID0gZWFyY3V0KHRlbXAudmVydGljZXMsIHRlbXAuaG9sZXMsIHRlbXAuZGltZW5zaW9ucyk7XHJcbiAgICAgICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0ZXg6IHRlbXBWZXJ0cyB9KTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9seWFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5YXJyYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzRGF0YShnZW9qc29uKSB7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZEdlb0pTT04oZ2VvanNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQW5kSW5zZXJ0RmVhdHVyZShpZCwgZ2VvbWV0cnksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbnVlbmQgIT0gdW5kZWZpbmVkICYmIHRoaXMuc3VidHJhaGVuZCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAmJiBwcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0gIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0gPT0gJ251bWJlcidcclxuICAgICAgICAgICAgJiYgcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW3RoaXMuYXR0cl0gPSBwcm9wZXJ0aWVzW3RoaXMubWludWVuZF0gLSBwcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PSBcIlBvbHlnb25cIiB8fCBnZW9tZXRyeS50eXBlID09IFwiTXVsdGlQb2x5Z29uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNQb2x5Z29ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25zID0gdGhpcy5wcm9jZXNzUG9seWdvbih7IGdlb21ldHJ5LCBwcm9wZXJ0aWVzIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEJvcmRlcnMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJUID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckIgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9seWdvbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlc3BvbHlnb24gPSBwb2x5Z29uc1tqXS50cmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3JkZXIgPSBwb2x5Z29uc1tqXS52ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJpYW5nbGVzW2pdID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Qm9yZGVyc1tqXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCB0cmlhbmdsZXNwb2x5Z29uLmxlbmd0aDsgaCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGJvcmRlclt0cmlhbmdsZXNwb2x5Z29uW2hdICogMl0sIGJvcmRlclt0cmlhbmdsZXNwb2x5Z29uW2hdICogMiArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJpYW5nbGVzW2pdLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoID09IHRyaWFuZ2xlc3BvbHlnb24ubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJULnB1c2goZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VycmVudFRyaWFuZ2xlc1tqXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5mc2l6ZSA9IHZlcnRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlclRbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJUW2pdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyVFtqXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBib3JkZXIubGVuZ3RoOyB5ICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoYm9yZGVyW3ldLCBib3JkZXJbeSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qm9yZGVyc1tqXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PSBib3JkZXIubGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCLnB1c2goZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VycmVudEJvcmRlcnNbal0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJCW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQltqXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJbal0ubnVtSXRlbXMgPSB2ZXJ0QXJyYXkubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vcG9seWdvblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIGJ1ZmZlclQsIGJ1ZmZlckIsIFtdKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09IFwiUG9pbnRcIiAmJiB0aGlzLmR5bmFtaWMgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAvL2R1bVxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHNbMF0gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHNbMF0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyUCA9IFtdO1xyXG4gICAgICAgICAgICBidWZmZXJQLnB1c2goZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VycmVudFBvaW50c1swXSk7XHJcblxyXG4gICAgICAgICAgICBnbC5mc2l6ZSA9IHZlcnRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlclBbMF0pO1xyXG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJQWzBdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgYnVmZmVyUFswXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pbnNlcnRGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCBbXSwgW10sIGJ1ZmZlclApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudHJlZXBvaW50cyA9PSBudWxsIHx8IHRoaXMudHJlZXBvaW50cyA9PSB1bmRlZmluZWQpIHRoaXMudHJlZXBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVwb2ludHMucHVzaCh7IGxvbjogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGxhdDogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIHByb3BlcnRpZXMgfSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2ludFwiICYmIHRoaXMuZHluYW1pYyA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvL2RlYnVnZ2VyO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcFBvaW50cyA9PSBudWxsIHx8IHRoaXMudGVtcFBvaW50cyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVtcFBvaW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBQb2ludHNbYV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYWVzYXJyYXlzID0gdGhpcy5maXRGZWF0dXJlKHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFlc2FycmF5cy5sZW5ndGg7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wUG9pbnRzW2Flc2FycmF5c1t5XV0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudHJlZXBvaW50cyA9PSBudWxsKSB0aGlzLnRyZWVwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50cmVlcG9pbnRzLnB1c2goeyBsb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBsYXQ6IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBwcm9wZXJ0aWVzIH0pO1xyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRUcmVlcyhnZW9qc29uKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAodGhpcy50ZW1wUG9pbnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLnRlbXBQb2ludHMubGVuZ3RoOyB0KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHNbdF0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclAgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJQLnB1c2goZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudGVtcFBvaW50c1t0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJQWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclBbMF0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclBbMF0ubnVtSXRlbXMgPSB2ZXJ0QXJyYXkubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEdyb3VwZWRGZWF0dXJlKHQsIFtdLCBbXSwgYnVmZmVyUCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coZ2VvanNvbilcclxuICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMua2R0cmVlID0gbmV3IGtkVHJlZSh0aGlzLnRyZWVwb2ludHMsIChhLCBiKSA9PiAoYS5sb24gLSBiLmxvbikgKiogMiArIChhLmxhdCAtIGIubGF0KSAqKiAyLCBbXCJsb25cIiwgXCJsYXRcIiwgXCJwcm9wZXJ0aWVzXCJdKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNQb2x5Z29ucyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAvL3RoaXMucnRyZWUgPSBuZXcgUG9seWdvbkxvb2t1cChnZW9qc29uKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAUnVpIExPT0sgSSBXQVMgUkVNT1ZFRFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkR2VvSlNPTihnZW9qc29uKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzWydfZ2lzcGxheWlkJ10gPSBnO1xyXG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb2pzb24uZmVhdHVyZXNbZ10uZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQW5kSW5zZXJ0RmVhdHVyZShnLCBnZW9tZXRyeSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVpbGRUcmVlcyhnZW9qc29uKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQ2FudmFzKCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMubWFwLmNyZWF0ZUNhbnZhcyh0aGlzLmlkKTtcclxuXHJcbiAgICAgICAgLy9pbml0IHdlYmdsIHByb3BlcnRpZXNcclxuICAgICAgICB0aGlzLl93ZWJnbCA9IHtcclxuICAgICAgICAgICAgZ2w6IG51bGwsXHJcbiAgICAgICAgICAgIHByb2dyYW06IG51bGwsXHJcbiAgICAgICAgICAgIHByb2plY3Rpb246IG51bGxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wucHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2plY3Rpb24uc2V0KFsyIC8gY2FudmFzLndpZHRoLCAwLCAwLCAwLCAwLCAtMiAvIGNhbnZhcy5oZWlnaHQsIDAsIDAsIDAsIDAsIDAsIDAsIC0xLCAxLCAwLCAxXSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWFwLmdldENvbnRhaW5lcigpLm9mZnNldFdpZHRoLCB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmRpc2FibGUodGhpcy5fd2ViZ2wuZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldE51bWJlck9mRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlUHJvamVjdGlvbihtYXRyaXgsIHNjYWxlWCwgc2NhbGVZKSB7XHJcbiAgICAgICAgLy8gc2NhbGluZyB4IGFuZCB5LCB3aGljaCBpcyBqdXN0IHNjYWxpbmcgZmlyc3QgdHdvIHJvd3Mgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzBdICo9IHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMV0gKj0gc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFsyXSAqPSBzY2FsZVg7XHJcbiAgICAgICAgbWF0cml4WzNdICo9IHNjYWxlWDtcclxuXHJcbiAgICAgICAgbWF0cml4WzRdICo9IHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbNV0gKj0gc2NhbGVZO1xyXG4gICAgICAgIG1hdHJpeFs2XSAqPSBzY2FsZVk7XHJcbiAgICAgICAgbWF0cml4WzddICo9IHNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeCwgdHgsIHR5KSB7XHJcbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgaW4gbGFzdCByb3cgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzEyXSArPSBtYXRyaXhbMF0gKiB0eCArIG1hdHJpeFs0XSAqIHR5O1xyXG4gICAgICAgIG1hdHJpeFsxM10gKz0gbWF0cml4WzFdICogdHggKyBtYXRyaXhbNV0gKiB0eTtcclxuICAgICAgICBtYXRyaXhbMTRdICs9IG1hdHJpeFsyXSAqIHR4ICsgbWF0cml4WzZdICogdHk7XHJcbiAgICAgICAgbWF0cml4WzE1XSArPSBtYXRyaXhbM10gKiB0eCArIG1hdHJpeFs3XSAqIHR5O1xyXG4gICAgfVxyXG5cclxuICAgIGxhdExvbmdUb1BpeGVsWFkobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIGNvbnN0IHBpXzE4MCA9IE1hdGguUEkgLyAxODAuMDtcclxuICAgICAgICBjb25zdCBwaV80ID0gTWF0aC5QSSAqIDQ7XHJcbiAgICAgICAgY29uc3Qgc2luTGF0aXR1ZGUgPSBNYXRoLnNpbihsYXRpdHVkZSAqIHBpXzE4MCk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxZID0gKDAuNSAtIE1hdGgubG9nKCgxICsgc2luTGF0aXR1ZGUpIC8gKDEgLSBzaW5MYXRpdHVkZSkpIC8gKHBpXzQpKSAqIDI1NjtcclxuICAgICAgICBjb25zdCBwaXhlbFggPSAoKGxvbmdpdHVkZSArIDE4MCkgLyAzNjApICogMjU2O1xyXG5cclxuICAgICAgICBjb25zdCBwaXhlbCA9IHsgeDogcGl4ZWxYLCB5OiBwaXhlbFkgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpeGVsO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3VHJpYW5nbGVzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdCb3JkZXJzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAwLjApO1xyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuc3Ryb2tlQ29sb3JbMF0gLyAyNTUsIGFlcy5zdHJva2VDb2xvclsxXSAvIDI1NSwgYWVzLnN0cm9rZUNvbG9yWzJdIC8gMjU1LCBhZXMuc3Ryb2tlQ29sb3JbM10pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX0xPT1AsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvaW50cyhhZXMpIHtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA0LjAgKyBhZXMucG9pbnRTaXplLCBhZXMucG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAxLjApO1xyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWVzLl9mZWF0dXJlcy5sZW5ndGggJiYgdGhpcy5keW5hbWljID09IHRydWU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50cy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50c1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuZHluYW1pYyA9PSBmYWxzZSAmJiBhZXMuX2FsbEZlYXR1cmVzICE9IG51bGwgJiYgaSA8IGFlcy5fYWxsRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMtMik7XHRcclxuICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHVjb2xvcjtcclxuICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdO1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSkucmdiKCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSArIGRpZmYgLyB0aGlzLm1heCAvIDIpLnJnYigpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgLSBkaWZmIC8gdGhpcy5taW4gLyAyKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWNvbG9yID0gW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIHVjb2xvclswXSAvIDI1NSwgdWNvbG9yWzFdIC8gMjU1LCB1Y29sb3JbMl0gLyAyNTUsIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlcy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlc1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UHJvcG9yY2lvbmFsUG9pbnRzKGFlcykge1xyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCB0aGlzLmFscGhhKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBhZXMuX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHkgaW4gYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3B2YWx1ZSA9IHBhcnNlRmxvYXQoYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKCh0aGlzLm1heHBvaW50c2l6ZSAtIHRoaXMubWlucG9pbnRzaXplKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSkgKiAocHJvcHZhbHVlIC0gdGhpcy5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNC4wICsgdGVtcHBvaW50c2l6ZSAqIGN1cnJlbnRab29tIC8gNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIHRoaXMubWF4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1pbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcclxuICAgICAgICB0aGlzLnByb2dyYW0oKTtcclxuICAgICAgICBsZXQgbWFwcG9zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKG1hcHNbaV0uaWQgPT0gdGhpcy5pZClcclxuICAgICAgICAgICAgICAgIG1hcHBvcyA9IGk7XHJcbiAgICAgICAgdGhpcy5tYXAub25FdmVudCgnbW92ZScsXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFJ1aTogbXVkYXIgbyBwcm9maWxpbmcgZG8gd2luZG93IHBhcmEgb3V0cmEgY29pc2E/XCIpXHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBtYXBzW21hcHBvc10uZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIFpvb20vUGFuIChzZWd1bmRvcyk6JHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0dXBPbmNsaWNrKG1hcHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBPbmNsaWNrKG1hcHBvcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQFJ1aTogcHJvZmlsaW5nIG11ZGFyIGRlIHdpbmRvdyBwYXJhPyB8IFJ0cmVlIGUgS2RUcmVlXCIpXHJcbiAgICAgICAgbWFwc1ttYXBwb3NdLm1hcC5vbkV2ZW50KCdjbGljaycsIGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc3QgbGF0ID0gZS5sYXRsbmcubGF0O1xyXG4gICAgICAgICAgICBjb25zdCBsb24gPSBlLmxhdGxuZy5sbmc7XHJcblxyXG4gICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLnJ0cmVlICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvb2wgPSBtYXBzWzBdLnJ0cmVlLnNlYXJjaChsb24sIGxhdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9vbCA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhib29sLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXSAhPSBcIl9naXNwbGF5aWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5pbnRlcmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzKTsvL3RvZG9cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZCAmJiBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsKGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10ua2R0cmVlICE9IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5lYXJlc3QgPSBtYXBzW21hcHBvc10ua2R0cmVlLm5lYXJlc3QoeyBsYXQsIGxvbiB9LCAxLCAxMjggLyAoKDIgKiogKG1hcC5nZXRab29tKCkgKiAyKSkpKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0Lmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib29sID0gbmVhcmVzdFswXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2sgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2subGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYCR7bWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpICsgMV19OiAke2Jvb2wucHJvcGVydGllc1ttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGBcXG4ke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGJvb2wucHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW2ldICE9IFwiX2dpc3BsYXlpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYCR7a2V5c1tpXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW2tleXNbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGBcXG4ke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLmludGVyYWN0aXZlID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkICYmIG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwoYm9vbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIHByb2Nlc3NhbWVudG8gZGUgdW0gY2xpY2sgKHNlZ3VuZG9zKTogJHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmaXRGZWF0dXJlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2FdLmNoZWNrUHJvcGVydHkocHJvcGVydGllc1t0aGlzLmFlc3RoZXRpY3NbYV0uZ2V0QXR0cigpXSkgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRPcHRpb25zKG9wdGlvbnMsIGJnbWFwKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY3VzdG9tTWFwU2VydmljZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IGJnbWFwO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgQkdNYXBXcmFwcGVyKGJnbWFwKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyKCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID0gbnVsbDtcclxuICAgICAgICAgICAgLy9hcHBlbmQgb24gYmdtYXAgb2JqZWN0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vbmFkYVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93UHJvcGVydGllc09uQ2xpY2sgPSBvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGEgIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbHBoYSA6IDAuODtcclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gb3B0aW9ucy5pbnRlcmFjdGl2ZSA9PSB1bmRlZmluZWQgPyB0cnVlIDogIW9wdGlvbnMuaW50ZXJhY3RpdmU7XHJcbiAgICAgICAgdGhpcy5hdHRyID0gb3B0aW9ucy5hdHRyO1xyXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IG9wdGlvbnMubWVtb3J5U2F2ZXIgPT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhb3B0aW9ucy5tZW1vcnlTYXZlcjtcclxuICAgICAgICB0aGlzLm1heGZlYXR1cmVzID0gb3B0aW9ucy5tYXhGZWF0dXJlcztcclxuICAgICAgICB0aGlzLmJyZWFrcyA9IG9wdGlvbnMuY2xhc3NCcmVha3M7XHJcbiAgICAgICAgdGhpcy5jb2xvcnNjaGVtZSA9IG9wdGlvbnMuY29sb3JTY2hlbWU7XHJcbiAgICAgICAgdGhpcy5udW1iZXJvZmNsYXNzZXMgPSBvcHRpb25zLm51bWJlck9mQ2xhc3NlcztcclxuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IG9wdGlvbnMuY2xhc3NCcmVha3NNZXRob2Q7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPbkNsaWNrQ2FsbCA9IG9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMubWFwT25DbGlja0NhbGwgPSBvcHRpb25zLm1hcE9uQ2xpY2tGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLm1pbnVlbmQgPSBvcHRpb25zLm1pbnVlbmQ7XHJcbiAgICAgICAgdGhpcy5zdWJ0cmFoZW5kID0gb3B0aW9ucy5zdWJ0cmFoZW5kO1xyXG4gICAgICAgIHRoaXMubGVnZW5kVGl0bGUgPSBvcHRpb25zLmxlZ2VuZFRpdGxlICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubGVnZW5kVGl0bGUgOiAodGhpcy5hdHRyICE9IHVuZGVmaW5lZCA/IHRoaXMuYXR0ciA6IGAke3RoaXMubWludWVuZH0gLSAke3RoaXMuc3VidHJhaGVuZH1gKTtcclxuICAgICAgICB0aGlzLm51bWJlck9mTGVnZW5kSXRlbXMgPSBvcHRpb25zLm51bWJlck9mTGVnZW5kSXRlbXMgIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5udW1iZXJPZkxlZ2VuZEl0ZW1zIDogMjtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5tYXAubG9hZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0hlYXRQb2ludHMoYWVzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuXHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdKTtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcblxyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAncG9zaXRpb24nKTtcclxuICAgICAgICBjb25zdCBkZWx0YUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdkZWx0YScpO1xyXG4gICAgICAgIGNvbnN0IGludGVuc2l0eUxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnaW50ZW5zaXR5Jyk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdhUG9pbnRTaXplJyk7XHJcblxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29vcmRMb2NhdGlvbik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZGVsdGFMb2NhdGlvbik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW50ZW5zaXR5TG9jKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fYWxsRmVhdHVyZXNbMF0uX3BvaW50c1swXSk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogOCwgMCAqIDIpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoZGVsdGFMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDIgKiA0KTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGludGVuc2l0eUxvYywgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDQgKiA0KTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0ubnVtSXRlbXMpO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0ubnVtSXRlbXMpO1xyXG5cclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSk7XHJcblxyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmFzZSAxIGNvbmNsdWlkYVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7dGhpcy5pZH1gKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHNvdXJjZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjYW52YXMpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpc1Bvd2VyT2YyKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT0gMDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzdGV1cFRleHR1cmVGaWx0ZXJpbmdBbmRNaXBzKHdpZHRoLCBoZWlnaHQsIGdsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Bvd2VyT2YyKHdpZHRoKSAmJiBpc1Bvd2VyT2YyKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBkaW1lbnNpb25zIGFyZSBwb3dlciBvZiAyIHNvIGdlbmVyYXRlIG1pcHMgYW5kIHR1cm4gb24gXHJcbiAgICAgICAgICAgICAgICAvLyB0cmktbGluZWFyIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSBvZiB0aGUgZGltZW5zaW9ucyBpcyBub3QgYSBwb3dlciBvZiAyIHNvIHNldCB0aGUgZmlsdGVyaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBXZWJHTCB3aWxsIHJlbmRlciBpdC5cclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuXHJcbiAgICAgICAgc3RldXBUZXh0dXJlRmlsdGVyaW5nQW5kTWlwcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIGdsKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIC0xXSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25Mb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzFdLCAnc291cmNlJyk7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2MpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNvdXJjZUxvYywgMCk7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xyXG5cclxuXHJcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jKTtcclxuICAgICAgICAvL2RlZmF1bHRzIHRvIGdlbmVyYWwgcHJvZ3JhbVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJmYXNlIDIgY29uY2x1aWRhXCIpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC51c2VQcm9ncmFtKHRoaXMuX3dlYmdsLnByb2dyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE51bWJlck9mUG9seWdvbnMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMuYWVzdGhldGljc1tpXS5fZmVhdHVyZXMubGVuZ3RoOyB6KyspIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ICs9IHRoaXMuYWVzdGhldGljc1tpXS5fZmVhdHVyZXNbel0uX3RyaWFuZ2xlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9FUzZUZXN0L01hcHMvTWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQTJCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMkRBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/lib/chroma.min.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*\r\nchroma.js - JavaScript library for color conversions\r\n\r\nCopyright (c) 2011-2015, Gregor Aisch\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n\r\n1. Redistributions of source code must retain the above copyright notice, this\r\n   list of conditions and the following disclaimer.\r\n\r\n2. Redistributions in binary form must reproduce the above copyright notice,\r\n   this list of conditions and the following disclaimer in the documentation\r\n   and/or other materials provided with the distribution.\r\n\r\n3. The name Gregor Aisch may not be used to endorse or promote products\r\n   derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\r\nOF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n*/\n(function () {\n   var a,\n       b,\n       c,\n       d,\n       e,\n       f,\n       g,\n       h,\n       i,\n       j,\n       k,\n       l,\n       m,\n       _n,\n       _o,\n       p,\n       q,\n       r,\n       s,\n       t,\n       u,\n       v,\n       w,\n       x,\n       y,\n       z,\n       A,\n       B,\n       C,\n       D,\n       E,\n       F,\n       G,\n       H,\n       I,\n       J,\n       K,\n       L,\n       M,\n       N,\n       O,\n       P,\n       Q,\n       R,\n       S,\n       T,\n       U,\n       V,\n       W,\n       X,\n       Y,\n       Z,\n       $,\n       _,\n       aa,\n       ba,\n       ca,\n       da,\n       ea,\n       fa,\n       ga,\n       ha,\n       ia,\n       ja,\n       ka,\n       la,\n       ma,\n       na,\n       oa,\n       pa,\n       qa,\n       ra,\n       sa,\n       ta,\n       ua,\n       va,\n       wa,\n       xa,\n       ya,\n       za = [].slice;ua = function () {\n      var a, b, c, d, e;for (a = {}, e = \"Boolean Number String Function Array Date RegExp Undefined Null\".split(\" \"), d = 0, b = e.length; b > d; d++) {\n         c = e[d], a[\"[object \" + c + \"]\"] = c.toLowerCase();\n      }return function (b) {\n         var c;return c = Object.prototype.toString.call(b), a[c] || \"object\";\n      };\n   }(), S = function S(a, b, c) {\n      return null == b && (b = 0), null == c && (c = 1), b > a && (a = b), a > c && (a = c), a;\n   }, va = function va(a) {\n      return a.length >= 3 ? [].slice.call(a) : a[0];\n   }, t = function t(a) {\n      var b;for (b in a) {\n         3 > b ? (a[b] < 0 && (a[b] = 0), a[b] > 255 && (a[b] = 255)) : 3 === b && (a[b] < 0 && (a[b] = 0), a[b] > 1 && (a[b] = 1));\n      }return a;\n   }, d = Math.PI, pa = Math.round, w = Math.cos, B = Math.floor, _ = Math.pow, T = Math.log, ra = Math.sin, sa = Math.sqrt, m = Math.atan2, W = Math.max, l = Math.abs, g = 2 * d, e = d / 3, b = d / 180, f = 180 / d, s = function s() {\n      return arguments[0] instanceof a ? arguments[0] : function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, arguments, function () {});\n   }, k = [], \"undefined\" != typeof module && null !== module && null != module.exports && (module.exports = s),  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return s;\n   }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (oa = \"undefined\" != typeof exports && null !== exports ? exports : this, oa.chroma = s), s.version = \"1.1.1\", j = {}, h = [], i = !1, a = function () {\n      function a() {\n         var a, b, c, d, e, f, g, k, l;for (f = this, b = [], k = 0, d = arguments.length; d > k; k++) {\n            a = arguments[k], null != a && b.push(a);\n         }if (g = b[b.length - 1], null != j[g]) f._rgb = t(j[g](va(b.slice(0, -1))));else {\n            for (i || (h = h.sort(function (a, b) {\n               return b.p - a.p;\n            }), i = !0), l = 0, e = h.length; e > l && (c = h[l], !(g = c.test.apply(c, b))); l++) {}g && (f._rgb = t(j[g].apply(j, b)));\n         }null == f._rgb && console.warn(\"unknown format: \" + b), null == f._rgb && (f._rgb = [0, 0, 0]), 3 === f._rgb.length && f._rgb.push(1);\n      }return a.prototype.alpha = function (a) {\n         return arguments.length ? (this._rgb[3] = a, this) : this._rgb[3];\n      }, a.prototype.toString = function () {\n         return this.name();\n      }, a;\n   }(), s._input = j, s.brewer = q = { OrRd: [\"#fff7ec\", \"#fee8c8\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#b30000\", \"#7f0000\"], PuBu: [\"#fff7fb\", \"#ece7f2\", \"#d0d1e6\", \"#a6bddb\", \"#74a9cf\", \"#3690c0\", \"#0570b0\", \"#045a8d\", \"#023858\"], BuPu: [\"#f7fcfd\", \"#e0ecf4\", \"#bfd3e6\", \"#9ebcda\", \"#8c96c6\", \"#8c6bb1\", \"#88419d\", \"#810f7c\", \"#4d004b\"], Oranges: [\"#fff5eb\", \"#fee6ce\", \"#fdd0a2\", \"#fdae6b\", \"#fd8d3c\", \"#f16913\", \"#d94801\", \"#a63603\", \"#7f2704\"], BuGn: [\"#f7fcfd\", \"#e5f5f9\", \"#ccece6\", \"#99d8c9\", \"#66c2a4\", \"#41ae76\", \"#238b45\", \"#006d2c\", \"#00441b\"], YlOrBr: [\"#ffffe5\", \"#fff7bc\", \"#fee391\", \"#fec44f\", \"#fe9929\", \"#ec7014\", \"#cc4c02\", \"#993404\", \"#662506\"], YlGn: [\"#ffffe5\", \"#f7fcb9\", \"#d9f0a3\", \"#addd8e\", \"#78c679\", \"#41ab5d\", \"#238443\", \"#006837\", \"#004529\"], Reds: [\"#fff5f0\", \"#fee0d2\", \"#fcbba1\", \"#fc9272\", \"#fb6a4a\", \"#ef3b2c\", \"#cb181d\", \"#a50f15\", \"#67000d\"], RdPu: [\"#fff7f3\", \"#fde0dd\", \"#fcc5c0\", \"#fa9fb5\", \"#f768a1\", \"#dd3497\", \"#ae017e\", \"#7a0177\", \"#49006a\"], Greens: [\"#f7fcf5\", \"#e5f5e0\", \"#c7e9c0\", \"#a1d99b\", \"#74c476\", \"#41ab5d\", \"#238b45\", \"#006d2c\", \"#00441b\"], YlGnBu: [\"#ffffd9\", \"#edf8b1\", \"#c7e9b4\", \"#7fcdbb\", \"#41b6c4\", \"#1d91c0\", \"#225ea8\", \"#253494\", \"#081d58\"], Purples: [\"#fcfbfd\", \"#efedf5\", \"#dadaeb\", \"#bcbddc\", \"#9e9ac8\", \"#807dba\", \"#6a51a3\", \"#54278f\", \"#3f007d\"], GnBu: [\"#f7fcf0\", \"#e0f3db\", \"#ccebc5\", \"#a8ddb5\", \"#7bccc4\", \"#4eb3d3\", \"#2b8cbe\", \"#0868ac\", \"#084081\"], Greys: [\"#ffffff\", \"#f0f0f0\", \"#d9d9d9\", \"#bdbdbd\", \"#969696\", \"#737373\", \"#525252\", \"#252525\", \"#000000\"], YlOrRd: [\"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#bd0026\", \"#800026\"], PuRd: [\"#f7f4f9\", \"#e7e1ef\", \"#d4b9da\", \"#c994c7\", \"#df65b0\", \"#e7298a\", \"#ce1256\", \"#980043\", \"#67001f\"], Blues: [\"#f7fbff\", \"#deebf7\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#08519c\", \"#08306b\"], PuBuGn: [\"#fff7fb\", \"#ece2f0\", \"#d0d1e6\", \"#a6bddb\", \"#67a9cf\", \"#3690c0\", \"#02818a\", \"#016c59\", \"#014636\"], Spectral: [\"#9e0142\", \"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#e6f598\", \"#abdda4\", \"#66c2a5\", \"#3288bd\", \"#5e4fa2\"], RdYlGn: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\", \"#006837\"], RdBu: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#f7f7f7\", \"#d1e5f0\", \"#92c5de\", \"#4393c3\", \"#2166ac\", \"#053061\"], PiYG: [\"#8e0152\", \"#c51b7d\", \"#de77ae\", \"#f1b6da\", \"#fde0ef\", \"#f7f7f7\", \"#e6f5d0\", \"#b8e186\", \"#7fbc41\", \"#4d9221\", \"#276419\"], PRGn: [\"#40004b\", \"#762a83\", \"#9970ab\", \"#c2a5cf\", \"#e7d4e8\", \"#f7f7f7\", \"#d9f0d3\", \"#a6dba0\", \"#5aae61\", \"#1b7837\", \"#00441b\"], RdYlBu: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee090\", \"#ffffbf\", \"#e0f3f8\", \"#abd9e9\", \"#74add1\", \"#4575b4\", \"#313695\"], BrBG: [\"#543005\", \"#8c510a\", \"#bf812d\", \"#dfc27d\", \"#f6e8c3\", \"#f5f5f5\", \"#c7eae5\", \"#80cdc1\", \"#35978f\", \"#01665e\", \"#003c30\"], RdGy: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#ffffff\", \"#e0e0e0\", \"#bababa\", \"#878787\", \"#4d4d4d\", \"#1a1a1a\"], PuOr: [\"#7f3b08\", \"#b35806\", \"#e08214\", \"#fdb863\", \"#fee0b6\", \"#f7f7f7\", \"#d8daeb\", \"#b2abd2\", \"#8073ac\", \"#542788\", \"#2d004b\"], Set2: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\", \"#e5c494\", \"#b3b3b3\"], Accent: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\", \"#386cb0\", \"#f0027f\", \"#bf5b17\", \"#666666\"], Set1: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\", \"#a65628\", \"#f781bf\", \"#999999\"], Set3: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\", \"#bc80bd\", \"#ccebc5\", \"#ffed6f\"], Dark2: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\", \"#a6761d\", \"#666666\"], Paired: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#cab2d6\", \"#6a3d9a\", \"#ffff99\", \"#b15928\"], Pastel2: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\", \"#e6f5c9\", \"#fff2ae\", \"#f1e2cc\", \"#cccccc\"], Pastel1: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\", \"#ffffcc\", \"#e5d8bd\", \"#fddaec\", \"#f2f2f2\"] }, wa = { indigo: \"#4b0082\", gold: \"#ffd700\", hotpink: \"#ff69b4\", firebrick: \"#b22222\", indianred: \"#cd5c5c\", yellow: \"#ffff00\", mistyrose: \"#ffe4e1\", darkolivegreen: \"#556b2f\", olive: \"#808000\", darkseagreen: \"#8fbc8f\", pink: \"#ffc0cb\", tomato: \"#ff6347\", lightcoral: \"#f08080\", orangered: \"#ff4500\", navajowhite: \"#ffdead\", lime: \"#00ff00\", palegreen: \"#98fb98\", darkslategrey: \"#2f4f4f\", greenyellow: \"#adff2f\", burlywood: \"#deb887\", seashell: \"#fff5ee\", mediumspringgreen: \"#00fa9a\", fuchsia: \"#ff00ff\", papayawhip: \"#ffefd5\", blanchedalmond: \"#ffebcd\", chartreuse: \"#7fff00\", dimgray: \"#696969\", black: \"#000000\", peachpuff: \"#ffdab9\", springgreen: \"#00ff7f\", aquamarine: \"#7fffd4\", white: \"#ffffff\", orange: \"#ffa500\", lightsalmon: \"#ffa07a\", darkslategray: \"#2f4f4f\", brown: \"#a52a2a\", ivory: \"#fffff0\", dodgerblue: \"#1e90ff\", peru: \"#cd853f\", lawngreen: \"#7cfc00\", chocolate: \"#d2691e\", crimson: \"#dc143c\", forestgreen: \"#228b22\", darkgrey: \"#a9a9a9\", lightseagreen: \"#20b2aa\", cyan: \"#00ffff\", mintcream: \"#f5fffa\", silver: \"#c0c0c0\", antiquewhite: \"#faebd7\", mediumorchid: \"#ba55d3\", skyblue: \"#87ceeb\", gray: \"#808080\", darkturquoise: \"#00ced1\", goldenrod: \"#daa520\", darkgreen: \"#006400\", floralwhite: \"#fffaf0\", darkviolet: \"#9400d3\", darkgray: \"#a9a9a9\", moccasin: \"#ffe4b5\", saddlebrown: \"#8b4513\", grey: \"#808080\", darkslateblue: \"#483d8b\", lightskyblue: \"#87cefa\", lightpink: \"#ffb6c1\", mediumvioletred: \"#c71585\", slategrey: \"#708090\", red: \"#ff0000\", deeppink: \"#ff1493\", limegreen: \"#32cd32\", darkmagenta: \"#8b008b\", palegoldenrod: \"#eee8aa\", plum: \"#dda0dd\", turquoise: \"#40e0d0\", lightgrey: \"#d3d3d3\", lightgoldenrodyellow: \"#fafad2\", darkgoldenrod: \"#b8860b\", lavender: \"#e6e6fa\", maroon: \"#800000\", yellowgreen: \"#9acd32\", sandybrown: \"#f4a460\", thistle: \"#d8bfd8\", violet: \"#ee82ee\", navy: \"#000080\", magenta: \"#ff00ff\", dimgrey: \"#696969\", tan: \"#d2b48c\", rosybrown: \"#bc8f8f\", olivedrab: \"#6b8e23\", blue: \"#0000ff\", lightblue: \"#add8e6\", ghostwhite: \"#f8f8ff\", honeydew: \"#f0fff0\", cornflowerblue: \"#6495ed\", slateblue: \"#6a5acd\", linen: \"#faf0e6\", darkblue: \"#00008b\", powderblue: \"#b0e0e6\", seagreen: \"#2e8b57\", darkkhaki: \"#bdb76b\", snow: \"#fffafa\", sienna: \"#a0522d\", mediumblue: \"#0000cd\", royalblue: \"#4169e1\", lightcyan: \"#e0ffff\", green: \"#008000\", mediumpurple: \"#9370db\", midnightblue: \"#191970\", cornsilk: \"#fff8dc\", paleturquoise: \"#afeeee\", bisque: \"#ffe4c4\", slategray: \"#708090\", darkcyan: \"#008b8b\", khaki: \"#f0e68c\", wheat: \"#f5deb3\", teal: \"#008080\", darkorchid: \"#9932cc\", deepskyblue: \"#00bfff\", salmon: \"#fa8072\", darkred: \"#8b0000\", steelblue: \"#4682b4\", palevioletred: \"#db7093\", lightslategray: \"#778899\", aliceblue: \"#f0f8ff\", lightslategrey: \"#778899\", lightgreen: \"#90ee90\", orchid: \"#da70d6\", gainsboro: \"#dcdcdc\", mediumseagreen: \"#3cb371\", lightgray: \"#d3d3d3\", mediumturquoise: \"#48d1cc\", lemonchiffon: \"#fffacd\", cadetblue: \"#5f9ea0\", lightyellow: \"#ffffe0\", lavenderblush: \"#fff0f5\", coral: \"#ff7f50\", purple: \"#800080\", aqua: \"#00ffff\", whitesmoke: \"#f5f5f5\", mediumslateblue: \"#7b68ee\", darkorange: \"#ff8c00\", mediumaquamarine: \"#66cdaa\", darksalmon: \"#e9967a\", beige: \"#f5f5dc\", blueviolet: \"#8a2be2\", azure: \"#f0ffff\", lightsteelblue: \"#b0c4de\", oldlace: \"#fdf5e6\", rebeccapurple: \"#663399\" }, s.colors = v = wa, N = function N() {\n      var a, b, d, e, f, g, h, i, j;return b = va(arguments), f = b[0], a = b[1], d = b[2], i = (f + 16) / 116, h = isNaN(a) ? i : i + a / 500, j = isNaN(d) ? i : i - d / 200, i = c.Yn * O(i), h = c.Xn * O(h), j = c.Zn * O(j), g = ya(3.2404542 * h - 1.5371385 * i - .4985314 * j), e = ya(-.969266 * h + 1.8760108 * i + .041556 * j), d = ya(.0556434 * h - .2040259 * i + 1.0572252 * j), g = S(g, 0, 255), e = S(e, 0, 255), d = S(d, 0, 255), [g, e, d, b.length > 3 ? b[3] : 1];\n   }, ya = function ya(a) {\n      return pa(255 * (.00304 >= a ? 12.92 * a : 1.055 * _(a, 1 / 2.4) - .055));\n   }, O = function O(a) {\n      return a > c.t1 ? a * a * a : c.t2 * (a - c.t0);\n   }, c = { Kn: 18, Xn: .95047, Yn: 1, Zn: 1.08883, t0: .137931034, t1: .206896552, t2: .12841855, t3: .008856452 }, ga = function ga() {\n      var a, b, c, d, e, f, g, h;return d = va(arguments), c = d[0], b = d[1], a = d[2], e = la(c, b, a), f = e[0], g = e[1], h = e[2], [116 * g - 16, 500 * (f - g), 200 * (g - h)];\n   }, ma = function ma(a) {\n      return (a /= 255) <= .04045 ? a / 12.92 : _((a + .055) / 1.055, 2.4);\n   }, xa = function xa(a) {\n      return a > c.t3 ? _(a, 1 / 3) : a / c.t2 + c.t0;\n   }, la = function la() {\n      var a, b, d, e, f, g, h;return e = va(arguments), d = e[0], b = e[1], a = e[2], d = ma(d), b = ma(b), a = ma(a), f = xa((.4124564 * d + .3575761 * b + .1804375 * a) / c.Xn), g = xa((.2126729 * d + .7151522 * b + .072175 * a) / c.Yn), h = xa((.0193339 * d + .119192 * b + .9503041 * a) / c.Zn), [f, g, h];\n   }, s.lab = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"lab\"]), function () {});\n   }, j.lab = N, a.prototype.lab = function () {\n      return ga(this._rgb);\n   }, _n = function n(a) {\n      var b, c, d, e, f, g, h, i, j, k, l;return a = function () {\n         var b, c, d;for (d = [], c = 0, b = a.length; b > c; c++) {\n            e = a[c], d.push(s(e));\n         }return d;\n      }(), 2 === a.length ? (j = function () {\n         var b, c, d;for (d = [], c = 0, b = a.length; b > c; c++) {\n            e = a[c], d.push(e.lab());\n         }return d;\n      }(), f = j[0], g = j[1], b = function b(a) {\n         var b, c;return c = function () {\n            var c, d;for (d = [], b = c = 0; 2 >= c; b = ++c) {\n               d.push(f[b] + a * (g[b] - f[b]));\n            }return d;\n         }(), s.lab.apply(s, c);\n      }) : 3 === a.length ? (k = function () {\n         var b, c, d;for (d = [], c = 0, b = a.length; b > c; c++) {\n            e = a[c], d.push(e.lab());\n         }return d;\n      }(), f = k[0], g = k[1], h = k[2], b = function b(a) {\n         var b, c;return c = function () {\n            var c, d;for (d = [], b = c = 0; 2 >= c; b = ++c) {\n               d.push((1 - a) * (1 - a) * f[b] + 2 * (1 - a) * a * g[b] + a * a * h[b]);\n            }return d;\n         }(), s.lab.apply(s, c);\n      }) : 4 === a.length ? (l = function () {\n         var b, c, d;for (d = [], c = 0, b = a.length; b > c; c++) {\n            e = a[c], d.push(e.lab());\n         }return d;\n      }(), f = l[0], g = l[1], h = l[2], i = l[3], b = function b(a) {\n         var b, c;return c = function () {\n            var c, d;for (d = [], b = c = 0; 2 >= c; b = ++c) {\n               d.push((1 - a) * (1 - a) * (1 - a) * f[b] + 3 * (1 - a) * (1 - a) * a * g[b] + 3 * (1 - a) * a * a * h[b] + a * a * a * i[b]);\n            }return d;\n         }(), s.lab.apply(s, c);\n      }) : 5 === a.length && (c = _n(a.slice(0, 3)), d = _n(a.slice(2, 5)), b = function b(a) {\n         return .5 > a ? c(2 * a) : d(2 * (a - .5));\n      }), b;\n   }, s.bezier = function (a) {\n      var b;return b = _n(a), b.scale = function () {\n         return s.scale(b);\n      }, b;\n   }, s.cubehelix = function (a, b, c, d, e) {\n      var f, h, i;return null == a && (a = 300), null == b && (b = -1.5), null == c && (c = 1), null == d && (d = 1), null == e && (e = [0, 1]), h = e[1] - e[0], f = 0, i = function i(_i) {\n         var j, k, l, m, n, o, p, q, r;return j = g * ((a + 120) / 360 + b * _i), p = _(e[0] + h * _i, d), o = 0 !== f ? c[0] + _i * f : c, k = o * p * (1 - p) / 2, m = w(j), r = ra(j), q = p + k * (-.14861 * m + 1.78277 * r), n = p + k * (-.29227 * m - .90649 * r), l = p + 1.97294 * k * m, s(t([255 * q, 255 * n, 255 * l]));\n      }, i.start = function (b) {\n         return null == b ? a : (a = b, i);\n      }, i.rotations = function (a) {\n         return null == a ? b : (b = a, i);\n      }, i.gamma = function (a) {\n         return null == a ? d : (d = a, i);\n      }, i.hue = function (a) {\n         return null == a ? c : (c = a, \"array\" === ua(c) ? (f = c[1] - c[0], 0 === f && (c = c[1])) : f = 0, i);\n      }, i.lightness = function (a) {\n         return null == a ? e : (e = a, \"array\" === ua(e) ? (h = e[1] - e[0], 0 === h && (e = e[1])) : h = 0, i);\n      }, i.scale = function () {\n         return s.scale(i);\n      }, i.hue(c), i;\n   }, s.random = function () {\n      var b, c, d, e;for (c = \"0123456789abcdef\", b = \"#\", d = e = 0; 6 > e; d = ++e) {\n         b += c.charAt(B(16 * Math.random()));\n      }return new a(b);\n   }, j.rgb = function () {\n      var a, b, c, d;b = va(arguments), c = [];for (a in b) {\n         d = b[a], c.push(d);\n      }return c;\n   }, s.rgb = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"rgb\"]), function () {});\n   }, a.prototype.rgb = function () {\n      return this._rgb.slice(0, 3);\n   }, a.prototype.rgba = function () {\n      return this._rgb;\n   }, h.push({ p: 15, test: function test(a) {\n         var b;return b = va(arguments), \"array\" === ua(b) && 3 === b.length ? \"rgb\" : 4 === b.length && \"number\" === ua(b[3]) && b[3] >= 0 && b[3] <= 1 ? \"rgb\" : void 0;\n      } }), C = function C(a) {\n      var b, c, d, e, f, g;if (a.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) return (4 === a.length || 7 === a.length) && (a = a.substr(1)), 3 === a.length && (a = a.split(\"\"), a = a[0] + a[0] + a[1] + a[1] + a[2] + a[2]), g = parseInt(a, 16), e = g >> 16, d = g >> 8 & 255, c = 255 & g, [e, d, c, 1];if (a.match(/^#?([A-Fa-f0-9]{8})$/)) return 9 === a.length && (a = a.substr(1)), g = parseInt(a, 16), e = g >> 24 & 255, d = g >> 16 & 255, c = g >> 8 & 255, b = pa((255 & g) / 255 * 100) / 100, [e, d, c, b];if (null != j.css && (f = j.css(a))) return f;throw \"unknown color: \" + a;\n   }, ca = function ca(a, b) {\n      var c, d, e, f, g, h, i;return null == b && (b = \"rgb\"), g = a[0], e = a[1], d = a[2], c = a[3], i = g << 16 | e << 8 | d, h = \"000000\" + i.toString(16), h = h.substr(h.length - 6), f = \"0\" + pa(255 * c).toString(16), f = f.substr(f.length - 2), \"#\" + function () {\n         switch (b.toLowerCase()) {case \"rgba\":\n               return h + f;case \"argb\":\n               return f + h;default:\n               return h;}\n      }();\n   }, j.hex = function (a) {\n      return C(a);\n   }, s.hex = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"hex\"]), function () {});\n   }, a.prototype.hex = function (a) {\n      return null == a && (a = \"rgb\"), ca(this._rgb, a);\n   }, h.push({ p: 10, test: function test(a) {\n         return 1 === arguments.length && \"string\" === ua(a) ? \"hex\" : void 0;\n      } }), F = function F() {\n      var a, b, c, d, e, f, g, h, i, j, k, l, m, n;if (a = va(arguments), e = a[0], k = a[1], g = a[2], 0 === k) i = d = b = 255 * g;else {\n         for (n = [0, 0, 0], c = [0, 0, 0], m = .5 > g ? g * (1 + k) : g + k - g * k, l = 2 * g - m, e /= 360, n[0] = e + 1 / 3, n[1] = e, n[2] = e - 1 / 3, f = h = 0; 2 >= h; f = ++h) {\n            n[f] < 0 && (n[f] += 1), n[f] > 1 && (n[f] -= 1), 6 * n[f] < 1 ? c[f] = l + 6 * (m - l) * n[f] : 2 * n[f] < 1 ? c[f] = m : 3 * n[f] < 2 ? c[f] = l + (m - l) * (2 / 3 - n[f]) * 6 : c[f] = l;\n         }j = [pa(255 * c[0]), pa(255 * c[1]), pa(255 * c[2])], i = j[0], d = j[1], b = j[2];\n      }return a.length > 3 ? [i, d, b, a[3]] : [i, d, b];\n   }, ea = function ea(a, b, c) {\n      var d, e, f, g, h;return void 0 !== a && a.length >= 3 && (g = a, a = g[0], b = g[1], c = g[2]), a /= 255, b /= 255, c /= 255, f = Math.min(a, b, c), W = Math.max(a, b, c), e = (W + f) / 2, W === f ? (h = 0, d = Number.NaN) : h = .5 > e ? (W - f) / (W + f) : (W - f) / (2 - W - f), a === W ? d = (b - c) / (W - f) : b === W ? d = 2 + (c - a) / (W - f) : c === W && (d = 4 + (a - b) / (W - f)), d *= 60, 0 > d && (d += 360), [d, h, e];\n   }, s.hsl = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"hsl\"]), function () {});\n   }, j.hsl = F, a.prototype.hsl = function () {\n      return ea(this._rgb);\n   }, G = function G() {\n      var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r;if (a = va(arguments), e = a[0], p = a[1], r = a[2], r *= 255, 0 === p) i = d = b = r;else switch (360 === e && (e = 0), e > 360 && (e -= 360), 0 > e && (e += 360), e /= 60, f = B(e), c = e - f, g = r * (1 - p), h = r * (1 - p * c), q = r * (1 - p * (1 - c)), f) {case 0:\n            j = [r, q, g], i = j[0], d = j[1], b = j[2];break;case 1:\n            k = [h, r, g], i = k[0], d = k[1], b = k[2];break;case 2:\n            l = [g, r, q], i = l[0], d = l[1], b = l[2];break;case 3:\n            m = [g, h, r], i = m[0], d = m[1], b = m[2];break;case 4:\n            n = [q, g, r], i = n[0], d = n[1], b = n[2];break;case 5:\n            o = [r, g, h], i = o[0], d = o[1], b = o[2];}return i = pa(i), d = pa(d), b = pa(b), [i, d, b, a.length > 3 ? a[3] : 1];\n   }, fa = function fa() {\n      var a, b, c, d, e, f, g, h, i;return g = va(arguments), f = g[0], c = g[1], a = g[2], e = Math.min(f, c, a), W = Math.max(f, c, a), b = W - e, i = W / 255, 0 === W ? (d = Number.NaN, h = 0) : (h = b / W, f === W && (d = (c - a) / b), c === W && (d = 2 + (a - f) / b), a === W && (d = 4 + (f - c) / b), d *= 60, 0 > d && (d += 360)), [d, h, i];\n   }, s.hsv = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"hsv\"]), function () {});\n   }, j.hsv = G, a.prototype.hsv = function () {\n      return fa(this._rgb);\n   }, Z = function Z(a) {\n      var b, c, d;return \"number\" === ua(a) && a >= 0 && 16777215 >= a ? (d = a >> 16, c = a >> 8 & 255, b = 255 & a, [d, c, b, 1]) : (console.warn(\"unknown num color: \" + a), [0, 0, 0, 1]);\n   }, ja = function ja() {\n      var a, b, c, d;return d = va(arguments), c = d[0], b = d[1], a = d[2], (c << 16) + (b << 8) + a;\n   }, s.num = function (b) {\n      return new a(b, \"num\");\n   }, a.prototype.num = function (a) {\n      return null == a && (a = \"rgb\"), ja(this._rgb, a);\n   }, j.num = Z, h.push({ p: 10, test: function test(a) {\n         return 1 === arguments.length && \"number\" === ua(a) && a >= 0 && 16777215 >= a ? \"num\" : void 0;\n      } }), x = function x(a) {\n      var b, c, d, e, f, g, h, i;if (a = a.toLowerCase(), null != s.colors && s.colors[a]) return C(s.colors[a]);if (f = a.match(/rgb\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*\\)/)) {\n         for (h = f.slice(1, 4), e = g = 0; 2 >= g; e = ++g) {\n            h[e] = +h[e];\n         }h[3] = 1;\n      } else if (f = a.match(/rgba\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) for (h = f.slice(1, 5), e = i = 0; 3 >= i; e = ++i) {\n         h[e] = +h[e];\n      } else if (f = a.match(/rgb\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) {\n         for (h = f.slice(1, 4), e = b = 0; 2 >= b; e = ++b) {\n            h[e] = pa(2.55 * h[e]);\n         }h[3] = 1;\n      } else if (f = a.match(/rgba\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n         for (h = f.slice(1, 5), e = c = 0; 2 >= c; e = ++c) {\n            h[e] = pa(2.55 * h[e]);\n         }h[3] = +h[3];\n      } else (f = a.match(/hsl\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) ? (d = f.slice(1, 4), d[1] *= .01, d[2] *= .01, h = F(d), h[3] = 1) : (f = a.match(/hsla\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) && (d = f.slice(1, 4), d[1] *= .01, d[2] *= .01, h = F(d), h[3] = +f[4]);return h;\n   }, ba = function ba(a) {\n      var b;return b = a[3] < 1 ? \"rgba\" : \"rgb\", \"rgb\" === b ? b + \"(\" + a.slice(0, 3).map(pa).join(\",\") + \")\" : \"rgba\" === b ? b + \"(\" + a.slice(0, 3).map(pa).join(\",\") + \",\" + a[3] + \")\" : void 0;\n   }, na = function na(a) {\n      return pa(100 * a) / 100;\n   }, E = function E(a, b) {\n      var c;return c = 1 > b ? \"hsla\" : \"hsl\", a[0] = na(a[0] || 0), a[1] = na(100 * a[1]) + \"%\", a[2] = na(100 * a[2]) + \"%\", \"hsla\" === c && (a[3] = b), c + \"(\" + a.join(\",\") + \")\";\n   }, j.css = function (a) {\n      return x(a);\n   }, s.css = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"css\"]), function () {});\n   }, a.prototype.css = function (a) {\n      return null == a && (a = \"rgb\"), \"rgb\" === a.slice(0, 3) ? ba(this._rgb) : \"hsl\" === a.slice(0, 3) ? E(this.hsl(), this.alpha()) : void 0;\n   }, j.named = function (a) {\n      return C(wa[a]);\n   }, h.push({ p: 20, test: function test(a) {\n         return 1 === arguments.length && null != wa[a] ? \"named\" : void 0;\n      } }), a.prototype.name = function (a) {\n      var b, c;arguments.length && (wa[a] && (this._rgb = C(wa[a])), this._rgb[3] = 1), b = this.hex();for (c in wa) {\n         if (b === wa[c]) return c;\n      }return b;\n   }, P = function P() {\n      var a, c, d, e;return e = va(arguments), d = e[0], a = e[1], c = e[2], c *= b, [d, w(c) * a, ra(c) * a];\n   }, Q = function Q() {\n      var a, b, c, d, e, f, g, h, i, j, k;return c = va(arguments), h = c[0], e = c[1], g = c[2], j = P(h, e, g), a = j[0], b = j[1], d = j[2], k = N(a, b, d), i = k[0], f = k[1], d = k[2], [S(i, 0, 255), S(f, 0, 255), S(d, 0, 255), c.length > 3 ? c[3] : 1];\n   }, M = function M() {\n      var a, b, c, d, e, g;return g = va(arguments), e = g[0], a = g[1], b = g[2], c = sa(a * a + b * b), d = (m(b, a) * f + 360) % 360, 0 === pa(1e4 * c) && (d = Number.NaN), [e, c, d];\n   }, ha = function ha() {\n      var a, b, c, d, e, f, g;return f = va(arguments), e = f[0], c = f[1], b = f[2], g = ga(e, c, b), d = g[0], a = g[1], b = g[2], M(d, a, b);\n   }, s.lch = function () {\n      var b;return b = va(arguments), new a(b, \"lch\");\n   }, s.hcl = function () {\n      var b;return b = va(arguments), new a(b, \"hcl\");\n   }, j.lch = Q, j.hcl = function () {\n      var a, b, c, d;return d = va(arguments), b = d[0], a = d[1], c = d[2], Q([c, a, b]);\n   }, a.prototype.lch = function () {\n      return ha(this._rgb);\n   }, a.prototype.hcl = function () {\n      return ha(this._rgb).reverse();\n   }, aa = function aa(a) {\n      var b, c, d, e, f, g, h, i, j;return null == a && (a = \"rgb\"), i = va(arguments), h = i[0], e = i[1], b = i[2], h /= 255, e /= 255, b /= 255, f = 1 - Math.max(h, Math.max(e, b)), d = 1 > f ? 1 / (1 - f) : 0, c = (1 - h - f) * d, g = (1 - e - f) * d, j = (1 - b - f) * d, [c, g, j, f];\n   }, u = function u() {\n      var a, b, c, d, e, f, g, h, i;return b = va(arguments), d = b[0], g = b[1], i = b[2], f = b[3], a = b.length > 4 ? b[4] : 1, 1 === f ? [0, 0, 0, a] : (h = d >= 1 ? 0 : pa(255 * (1 - d) * (1 - f)), e = g >= 1 ? 0 : pa(255 * (1 - g) * (1 - f)), c = i >= 1 ? 0 : pa(255 * (1 - i) * (1 - f)), [h, e, c, a]);\n   }, j.cmyk = function () {\n      return u(va(arguments));\n   }, s.cmyk = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"cmyk\"]), function () {});\n   }, a.prototype.cmyk = function () {\n      return aa(this._rgb);\n   }, j.gl = function () {\n      var a, b, c, d, e;for (d = function () {\n         var a, c;a = va(arguments), c = [];for (b in a) {\n            e = a[b], c.push(e);\n         }return c;\n      }.apply(this, arguments), a = c = 0; 2 >= c; a = ++c) {\n         d[a] *= 255;\n      }return d;\n   }, s.gl = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"gl\"]), function () {});\n   }, a.prototype.gl = function () {\n      var a;return a = this._rgb, [a[0] / 255, a[1] / 255, a[2] / 255, a[3]];\n   }, ia = function ia(a, b, c) {\n      var d;return d = va(arguments), a = d[0], b = d[1], c = d[2], a = U(a), b = U(b), c = U(c), .2126 * a + .7152 * b + .0722 * c;\n   }, U = function U(a) {\n      return a /= 255, .03928 >= a ? a / 12.92 : _((a + .055) / 1.055, 2.4);\n   }, k = [], H = function H(a, b, c, d) {\n      var e, f, g, h;for (null == c && (c = .5), null == d && (d = \"rgb\"), \"object\" !== ua(a) && (a = s(a)), \"object\" !== ua(b) && (b = s(b)), g = 0, f = k.length; f > g; g++) {\n         if (e = k[g], d === e[0]) {\n            h = e[1](a, b, c, d);break;\n         }\n      }if (null == h) throw \"color mode \" + d + \" is not supported\";return h.alpha(a.alpha() + c * (b.alpha() - a.alpha())), h;\n   }, s.interpolate = H, a.prototype.interpolate = function (a, b, c) {\n      return H(this, a, b, c);\n   }, s.mix = H, a.prototype.mix = a.prototype.interpolate, L = function L(b, c, d, e) {\n      var f, g;return f = b._rgb, g = c._rgb, new a(f[0] + d * (g[0] - f[0]), f[1] + d * (g[1] - f[1]), f[2] + d * (g[2] - f[2]), e);\n   }, k.push([\"rgb\", L]), a.prototype.luminance = function (a, b) {\n      var c, d, e, _f;return null == b && (b = \"rgb\"), arguments.length ? (0 === a ? this._rgb = [0, 0, 0, this._rgb[3]] : 1 === a ? this._rgb = [255, 255, 255, this._rgb[3]] : (d = 1e-7, e = 20, _f = function f(c, g) {\n         var h, i;return i = c.interpolate(g, .5, b), h = i.luminance(), Math.abs(a - h) < d || !e-- ? i : h > a ? _f(c, i) : _f(i, g);\n      }, c = ia(this._rgb), this._rgb = (c > a ? _f(s(\"black\"), this) : _f(this, s(\"white\"))).rgba()), this) : ia(this._rgb);\n   }, ta = function ta(a) {\n      var b, c, d, e;return e = a / 100, 66 > e ? (d = 255, c = -155.25485562709179 - .44596950469579133 * (c = e - 2) + 104.49216199393888 * T(c), b = 20 > e ? 0 : -254.76935184120902 + .8274096064007395 * (b = e - 10) + 115.67994401066147 * T(b)) : (d = 351.97690566805693 + .114206453784165 * (d = e - 55) - 40.25366309332127 * T(d), c = 325.4494125711974 + .07943456536662342 * (c = e - 50) - 28.0852963507957 * T(c), b = 255), t([d, c, b]);\n   }, ka = function ka() {\n      var a, b, c, d, e, f, g, h, i;for (g = va(arguments), f = g[0], c = g[1], a = g[2], e = 1e3, d = 4e4, b = .4; d - e > b;) {\n         i = .5 * (d + e), h = ta(i), h[2] / h[0] >= a / f ? d = i : e = i;\n      }return pa(i);\n   }, s.temperature = s.kelvin = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"temperature\"]), function () {});\n   }, j.temperature = j.kelvin = j.K = ta, a.prototype.temperature = function () {\n      return ka(this._rgb);\n   }, a.prototype.kelvin = a.prototype.temperature, s.contrast = function (b, c) {\n      var d, e, f, g;return (\"string\" === (f = ua(b)) || \"number\" === f) && (b = new a(b)), (\"string\" === (g = ua(c)) || \"number\" === g) && (c = new a(c)), d = b.luminance(), e = c.luminance(), d > e ? (d + .05) / (e + .05) : (e + .05) / (d + .05);\n   }, a.prototype.get = function (a) {\n      var b, c, d, e, f, g;return d = this, f = a.split(\".\"), e = f[0], b = f[1], g = d[e](), b ? (c = e.indexOf(b), c > -1 ? g[c] : console.warn(\"unknown channel \" + b + \" in mode \" + e)) : g;\n   }, a.prototype.set = function (a, b) {\n      var c, d, e, f, g, h;if (e = this, g = a.split(\".\"), f = g[0], c = g[1], c) {\n         if (h = e[f](), d = f.indexOf(c), d > -1) {\n            if (\"string\" === ua(b)) switch (b.charAt(0)) {case \"+\":\n                  h[d] += +b;break;case \"-\":\n                  h[d] += +b;break;case \"*\":\n                  h[d] *= +b.substr(1);break;case \"/\":\n                  h[d] /= +b.substr(1);break;default:\n                  h[d] = +b;} else h[d] = b;\n         } else console.warn(\"unknown channel \" + c + \" in mode \" + f);\n      } else h = b;return e._rgb = s(h, f).alpha(e.alpha())._rgb, e;\n   }, a.prototype.darken = function (a) {\n      var b, d;return null == a && (a = 1), d = this, b = d.lab(), b[0] -= c.Kn * a, s.lab(b).alpha(d.alpha());\n   }, a.prototype.brighten = function (a) {\n      return null == a && (a = 1), this.darken(-a);\n   }, a.prototype.darker = a.prototype.darken, a.prototype.brighter = a.prototype.brighten, a.prototype.saturate = function (a) {\n      var b, d;return null == a && (a = 1), d = this, b = d.lch(), b[1] += a * c.Kn, b[1] < 0 && (b[1] = 0), s.lch(b).alpha(d.alpha());\n   }, a.prototype.desaturate = function (a) {\n      return null == a && (a = 1), this.saturate(-a);\n   }, a.prototype.premultiply = function () {\n      var a, b;return b = this.rgb(), a = this.alpha(), s(b[0] * a, b[1] * a, b[2] * a, a);\n   }, _o = function o(a, b, c) {\n      if (!_o[c]) throw \"unknown blend mode \" + c;return _o[c](a, b);\n   }, p = function p(a) {\n      return function (b, c) {\n         var d, e;return d = s(c).rgb(), e = s(b).rgb(), s(a(d, e), \"rgb\");\n      };\n   }, A = function A(a) {\n      return function (b, c) {\n         var d, e, f;for (f = [], d = e = 0; 3 >= e; d = ++e) {\n            f[d] = a(b[d], c[d]);\n         }return f;\n      };\n   }, Y = function Y(a, b) {\n      return a;\n   }, X = function X(a, b) {\n      return a * b / 255;\n   }, y = function y(a, b) {\n      return a > b ? b : a;\n   }, R = function R(a, b) {\n      return a > b ? a : b;\n   }, qa = function qa(a, b) {\n      return 255 * (1 - (1 - a / 255) * (1 - b / 255));\n   }, $ = function $(a, b) {\n      return 128 > b ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\n   }, r = function r(a, b) {\n      return 255 * (1 - (1 - b / 255) / (a / 255));\n   }, z = function z(a, b) {\n      return 255 === a ? 255 : (a = 255 * (b / 255) / (1 - a / 255), a > 255 ? 255 : a);\n   }, _o.normal = p(A(Y)), _o.multiply = p(A(X)), _o.screen = p(A(qa)), _o.overlay = p(A($)), _o.darken = p(A(y)), _o.lighten = p(A(R)), _o.dodge = p(A(z)), _o.burn = p(A(r)), s.blend = _o, s.analyze = function (a) {\n      var b, c, d, e;for (d = { min: Number.MAX_VALUE, max: -1 * Number.MAX_VALUE, sum: 0, values: [], count: 0 }, c = 0, b = a.length; b > c; c++) {\n         e = a[c], null == e || isNaN(e) || (d.values.push(e), d.sum += e, e < d.min && (d.min = e), e > d.max && (d.max = e), d.count += 1);\n      }return d.domain = [d.min, d.max], d.limits = function (a, b) {\n         return s.limits(d, a, b);\n      }, d;\n   }, s.scale = function (a, b) {\n      var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, t, u, v, w, x;return k = \"rgb\", l = s(\"#ccc\"), p = 0, h = !1, g = [0, 1], o = [], n = [0, 0], c = !1, e = [], m = !1, j = 0, i = 1, f = !1, d = {}, w = function w(a) {\n         var b, c, d, f, g, h, i;if (null == a && (a = [\"#fff\", \"#000\"]), null != a && \"string\" === ua(a) && null != (null != (f = s.brewer) ? f[a] : void 0) && (a = s.brewer[a]), \"array\" === ua(a)) {\n            for (a = a.slice(0), b = d = 0, g = a.length - 1; g >= 0 ? g >= d : d >= g; b = g >= 0 ? ++d : --d) {\n               c = a[b], \"string\" === ua(c) && (a[b] = s(c));\n            }for (o.length = 0, b = i = 0, h = a.length - 1; h >= 0 ? h >= i : i >= h; b = h >= 0 ? ++i : --i) {\n               o.push(b / (a.length - 1));\n            }\n         }return v(), e = a;\n      }, t = function t(a) {\n         var b, d;if (null != c) {\n            for (d = c.length - 1, b = 0; d > b && a >= c[b];) {\n               b++;\n            }return b - 1;\n         }return 0;\n      }, x = function x(a) {\n         return a;\n      }, q = function q(a) {\n         var b, d, e, f, g;return g = a, c.length > 2 && (f = c.length - 1, b = t(a), e = c[0] + (c[1] - c[0]) * (0 + .5 * p), d = c[f - 1] + (c[f] - c[f - 1]) * (1 - .5 * p), g = j + (c[b] + .5 * (c[b + 1] - c[b]) - e) / (d - e) * (i - j)), g;\n      }, u = function u(a, b) {\n         var f, g, h, m, p, q, r, u;if (null == b && (b = !1), isNaN(a)) return l;if (b ? u = a : c && c.length > 2 ? (f = t(a), u = f / (c.length - 2), u = n[0] + u * (1 - n[0] - n[1])) : i !== j ? (u = (a - j) / (i - j), u = n[0] + u * (1 - n[0] - n[1]), u = Math.min(1, Math.max(0, u))) : u = 1, b || (u = x(u)), m = Math.floor(1e4 * u), d[m]) g = d[m];else {\n            if (\"array\" === ua(e)) for (h = p = 0, r = o.length - 1; r >= 0 ? r >= p : p >= r; h = r >= 0 ? ++p : --p) {\n               if (q = o[h], q >= u) {\n                  g = e[h];break;\n               }if (u >= q && h === o.length - 1) {\n                  g = e[h];break;\n               }if (u > q && u < o[h + 1]) {\n                  u = (u - q) / (o[h + 1] - q), g = s.interpolate(e[h], e[h + 1], u, k);break;\n               }\n            } else \"function\" === ua(e) && (g = e(u));d[m] = g;\n         }return g;\n      }, v = function v() {\n         return d = {};\n      }, w(a), r = function r(a) {\n         var b;return b = s(u(a)), m && b[m] ? b[m]() : b;\n      }, r.classes = function (a) {\n         var b;return null != a ? (\"array\" === ua(a) ? (c = a, g = [a[0], a[a.length - 1]]) : (b = s.analyze(g), c = 0 === a ? [b.min, b.max] : s.limits(b, \"e\", a)), r) : c;\n      }, r.domain = function (a) {\n         var b, c, d, f, h, k, l;if (!arguments.length) return g;if (j = a[0], i = a[a.length - 1], o = [], d = e.length, a.length === d && j !== i) for (h = 0, f = a.length; f > h; h++) {\n            c = a[h], o.push((c - j) / (i - j));\n         } else for (b = l = 0, k = d - 1; k >= 0 ? k >= l : l >= k; b = k >= 0 ? ++l : --l) {\n            o.push(b / (d - 1));\n         }return g = [j, i], r;\n      }, r.mode = function (a) {\n         return arguments.length ? (k = a, v(), r) : k;\n      }, r.range = function (a, b) {\n         return w(a, b), r;\n      }, r.out = function (a) {\n         return m = a, r;\n      }, r.spread = function (a) {\n         return arguments.length ? (p = a, r) : p;\n      }, r.correctLightness = function (a) {\n         return null == a && (a = !0), f = a, v(), x = f ? function (a) {\n            var b, c, d, e, f, g, h, i, j;for (b = u(0, !0).lab()[0], c = u(1, !0).lab()[0], h = b > c, d = u(a, !0).lab()[0], f = b + (c - b) * a, e = d - f, i = 0, j = 1, g = 20; Math.abs(e) > .01 && g-- > 0;) {\n               !function () {\n                  return h && (e *= -1), 0 > e ? (i = a, a += .5 * (j - a)) : (j = a, a += .5 * (i - a)), d = u(a, !0).lab()[0], e = d - f;\n               }();\n            }return a;\n         } : function (a) {\n            return a;\n         }, r;\n      }, r.padding = function (a) {\n         return null != a ? (\"number\" === ua(a) && (a = [a, a]), n = a, r) : n;\n      }, r.colors = function () {\n         var b, d, e, f, h, i, j, k, l;if (f = 0, h = \"hex\", 1 === arguments.length && (\"string\" === ua(arguments[0]) ? h = arguments[0] : f = arguments[0]), 2 === arguments.length && (f = arguments[0], h = arguments[1]), f) return d = g[0], b = g[1] - d, function () {\n            j = [];for (var a = 0; f >= 0 ? f > a : a > f; f >= 0 ? a++ : a--) {\n               j.push(a);\n            }return j;\n         }.apply(this).map(function (a) {\n            return r(d + a / (f - 1) * b)[h]();\n         });if (a = [], k = [], c && c.length > 2) for (e = l = 1, i = c.length; i >= 1 ? i > l : l > i; e = i >= 1 ? ++l : --l) {\n            k.push(.5 * (c[e - 1] + c[e]));\n         } else k = g;return k.map(function (a) {\n            return r(a)[h]();\n         });\n      }, r;\n   }, null == s.scales && (s.scales = {}), s.scales.cool = function () {\n      return s.scale([s.hsl(180, 1, .9), s.hsl(250, .7, .4)]);\n   }, s.scales.hot = function () {\n      return s.scale([\"#000\", \"#f00\", \"#ff0\", \"#fff\"], [0, .25, .75, 1]).mode(\"rgb\");\n   }, s.analyze = function (a, b, c) {\n      var d, e, f, g, h, i, j;if (h = { min: Number.MAX_VALUE, max: -1 * Number.MAX_VALUE, sum: 0, values: [], count: 0 }, null == c && (c = function c() {\n         return !0;\n      }), d = function d(a) {\n         null == a || isNaN(a) || (h.values.push(a), h.sum += a, a < h.min && (h.min = a), a > h.max && (h.max = a), h.count += 1);\n      }, j = function j(a, e) {\n         return c(a, e) ? d(null != b && \"function\" === ua(b) ? b(a) : null != b && \"string\" === ua(b) || \"number\" === ua(b) ? a[b] : a) : void 0;\n      }, \"array\" === ua(a)) for (g = 0, f = a.length; f > g; g++) {\n         i = a[g], j(i);\n      } else for (e in a) {\n         i = a[e], j(i, e);\n      }return h.domain = [h.min, h.max], h.limits = function (a, b) {\n         return s.limits(h, a, b);\n      }, h;\n   }, s.limits = function (a, b, c) {\n      var d, e, f, g, h, i, j, k, m, n, o, p, q, r, t, u, v, w, x, y, z, A, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, U, V, X, Y, Z, $, aa, ba, ca, da, ea, fa, ga, ha, ia, ja;if (null == b && (b = \"equal\"), null == c && (c = 7), \"array\" === ua(a) && (a = s.analyze(a)), E = a.min, W = a.max, fa = a.sum, ia = a.values.sort(function (a, b) {\n         return a - b;\n      }), C = [], \"c\" === b.substr(0, 1) && (C.push(E), C.push(W)), \"e\" === b.substr(0, 1)) {\n         for (C.push(E), y = K = 1, O = c - 1; O >= 1 ? O >= K : K >= O; y = O >= 1 ? ++K : --K) {\n            C.push(E + y / c * (W - E));\n         }C.push(W);\n      } else if (\"l\" === b.substr(0, 1)) {\n         if (0 >= E) throw \"Logarithmic scales are only possible for values > 0\";for (F = Math.LOG10E * T(E), D = Math.LOG10E * T(W), C.push(E), y = ja = 1, P = c - 1; P >= 1 ? P >= ja : ja >= P; y = P >= 1 ? ++ja : --ja) {\n            C.push(_(10, F + y / c * (D - F)));\n         }C.push(W);\n      } else if (\"q\" === b.substr(0, 1)) {\n         for (C.push(E), y = d = 1, X = c - 1; X >= 1 ? X >= d : d >= X; y = X >= 1 ? ++d : --d) {\n            L = ia.length * y / c, M = B(L), M === L ? C.push(ia[M]) : (N = L - M, C.push(ia[M] * N + ia[M + 1] * (1 - N)));\n         }C.push(W);\n      } else if (\"k\" === b.substr(0, 1)) {\n         for (H = ia.length, r = new Array(H), w = new Array(c), ea = !0, I = 0, u = null, u = [], u.push(E), y = e = 1, Y = c - 1; Y >= 1 ? Y >= e : e >= Y; y = Y >= 1 ? ++e : --e) {\n            u.push(E + y / c * (W - E));\n         }for (u.push(W); ea;) {\n            for (z = f = 0, Z = c - 1; Z >= 0 ? Z >= f : f >= Z; z = Z >= 0 ? ++f : --f) {\n               w[z] = 0;\n            }for (y = g = 0, $ = H - 1; $ >= 0 ? $ >= g : g >= $; y = $ >= 0 ? ++g : --g) {\n               for (ha = ia[y], G = Number.MAX_VALUE, z = h = 0, aa = c - 1; aa >= 0 ? aa >= h : h >= aa; z = aa >= 0 ? ++h : --h) {\n                  x = l(u[z] - ha), G > x && (G = x, t = z);\n               }w[t]++, r[y] = t;\n            }for (J = new Array(c), z = i = 0, ba = c - 1; ba >= 0 ? ba >= i : i >= ba; z = ba >= 0 ? ++i : --i) {\n               J[z] = null;\n            }for (y = j = 0, ca = H - 1; ca >= 0 ? ca >= j : j >= ca; y = ca >= 0 ? ++j : --j) {\n               v = r[y], null === J[v] ? J[v] = ia[y] : J[v] += ia[y];\n            }for (z = k = 0, da = c - 1; da >= 0 ? da >= k : k >= da; z = da >= 0 ? ++k : --k) {\n               J[z] *= 1 / w[z];\n            }for (ea = !1, z = m = 0, Q = c - 1; Q >= 0 ? Q >= m : m >= Q; z = Q >= 0 ? ++m : --m) {\n               if (J[z] !== u[y]) {\n                  ea = !0;break;\n               }\n            }u = J, I++, I > 200 && (ea = !1);\n         }for (A = {}, z = n = 0, R = c - 1; R >= 0 ? R >= n : n >= R; z = R >= 0 ? ++n : --n) {\n            A[z] = [];\n         }for (y = o = 0, S = H - 1; S >= 0 ? S >= o : o >= S; y = S >= 0 ? ++o : --o) {\n            v = r[y], A[v].push(ia[y]);\n         }for (ga = [], z = p = 0, U = c - 1; U >= 0 ? U >= p : p >= U; z = U >= 0 ? ++p : --p) {\n            ga.push(A[z][0]), ga.push(A[z][A[z].length - 1]);\n         }for (ga = ga.sort(function (a, b) {\n            return a - b;\n         }), C.push(ga[0]), y = q = 1, V = ga.length - 1; V >= q; y = q += 2) {\n            isNaN(ga[y]) || C.push(ga[y]);\n         }\n      }return C;\n   }, D = function D(a, b, c) {\n      var d, f, h, i;return d = va(arguments), a = d[0], b = d[1], c = d[2], a /= 360, 1 / 3 > a ? (f = (1 - b) / 3, i = (1 + b * w(g * a) / w(e - g * a)) / 3, h = 1 - (f + i)) : 2 / 3 > a ? (a -= 1 / 3, i = (1 - b) / 3, h = (1 + b * w(g * a) / w(e - g * a)) / 3, f = 1 - (i + h)) : (a -= 2 / 3, h = (1 - b) / 3, f = (1 + b * w(g * a) / w(e - g * a)) / 3, i = 1 - (h + f)), i = S(c * i * 3), h = S(c * h * 3), f = S(c * f * 3), [255 * i, 255 * h, 255 * f, d.length > 3 ? d[3] : 1];\n   }, da = function da() {\n      var a, b, c, d, e, f, h, i;return h = va(arguments), f = h[0], b = h[1], a = h[2], g = 2 * Math.PI, f /= 255, b /= 255, a /= 255, e = Math.min(f, b, a), d = (f + b + a) / 3, i = 1 - e / d, 0 === i ? c = 0 : (c = (f - b + (f - a)) / 2, c /= Math.sqrt((f - b) * (f - b) + (f - a) * (b - a)), c = Math.acos(c), a > b && (c = g - c), c /= g), [360 * c, i, d];\n   }, s.hsi = function () {\n      return function (a, b, c) {\n         c.prototype = a.prototype;var d = new c(),\n             e = a.apply(d, b);return Object(e) === e ? e : d;\n      }(a, za.call(arguments).concat([\"hsi\"]), function () {});\n   }, j.hsi = D, a.prototype.hsi = function () {\n      return da(this._rgb);\n   }, I = function I(a, b, c, d) {\n      var e, f, g, h, i, j, k, l, m, n, o, p, q;return \"hsl\" === d ? (p = a.hsl(), q = b.hsl()) : \"hsv\" === d ? (p = a.hsv(), q = b.hsv()) : \"hsi\" === d ? (p = a.hsi(), q = b.hsi()) : (\"lch\" === d || \"hcl\" === d) && (d = \"hcl\", p = a.hcl(), q = b.hcl()), \"h\" === d.substr(0, 1) && (g = p[0], n = p[1], j = p[2], h = q[0], o = q[1], k = q[2]), isNaN(g) || isNaN(h) ? isNaN(g) ? isNaN(h) ? f = Number.NaN : (f = h, 1 !== j && 0 !== j || \"hsv\" === d || (m = o)) : (f = g, 1 !== k && 0 !== k || \"hsv\" === d || (m = n)) : (e = h > g && h - g > 180 ? h - (g + 360) : g > h && g - h > 180 ? h + 360 - g : h - g, f = g + c * e), null == m && (m = n + c * (o - n)), i = j + c * (k - j), l = s[d](f, m, i);\n   }, k = k.concat(function () {\n      var a, b, c, d;for (c = [\"hsv\", \"hsl\", \"hsi\", \"hcl\", \"lch\"], d = [], b = 0, a = c.length; a > b; b++) {\n         V = c[b], d.push([V, I]);\n      }return d;\n   }()), K = function K(a, b, c, d) {\n      var e, f;return e = a.num(), f = b.num(), s.num(e + (f - e) * c, \"num\");\n   }, k.push([\"num\", K]), J = function J(b, c, d, e) {\n      var f, g, h;return g = b.lab(), h = c.lab(), f = new a(g[0] + d * (h[0] - g[0]), g[1] + d * (h[1] - g[1]), g[2] + d * (h[2] - g[2]), e);\n   }, k.push([\"lab\", J]);\n}).call(undefined);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../~/webpack/buildin/module.js */ 10)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL2Nocm9tYS5taW4uanM/ZWRlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5jaHJvbWEuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNvbG9yIGNvbnZlcnNpb25zXHJcblxyXG5Db3B5cmlnaHQgKGMpIDIwMTEtMjAxNSwgR3JlZ29yIEFpc2NoXHJcbkFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxubW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4xLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcblxyXG4yLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG4zLiBUaGUgbmFtZSBHcmVnb3IgQWlzY2ggbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xyXG4gICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcbkFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdSRUdPUiBBSVNDSCBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxyXG5JTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORyxcclxuQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcclxuREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxyXG5PRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG5ORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXHJcbkVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcblxyXG4qL1xyXG4oZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIscyx0LHUsdix3LHgseSx6LEEsQixDLEQsRSxGLEcsSCxJLEosSyxMLE0sTixPLFAsUSxSLFMsVCxVLFYsVyxYLFksWiwkLF8sYWEsYmEsY2EsZGEsZWEsZmEsZ2EsaGEsaWEsamEsa2EsbGEsbWEsbmEsb2EscGEscWEscmEsc2EsdGEsdWEsdmEsd2EseGEseWEsemE9W10uc2xpY2U7dWE9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlO2ZvcihhPXt9LGU9XCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgVW5kZWZpbmVkIE51bGxcIi5zcGxpdChcIiBcIiksZD0wLGI9ZS5sZW5ndGg7Yj5kO2QrKyljPWVbZF0sYVtcIltvYmplY3QgXCIrYytcIl1cIl09Yy50b0xvd2VyQ2FzZSgpO3JldHVybiBmdW5jdGlvbihiKXt2YXIgYztyZXR1cm4gYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYiksYVtjXXx8XCJvYmplY3RcIn19KCksUz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGw9PWImJihiPTApLG51bGw9PWMmJihjPTEpLGI+YSYmKGE9YiksYT5jJiYoYT1jKSxhfSx2YT1mdW5jdGlvbihhKXtyZXR1cm4gYS5sZW5ndGg+PTM/W10uc2xpY2UuY2FsbChhKTphWzBdfSx0PWZ1bmN0aW9uKGEpe3ZhciBiO2ZvcihiIGluIGEpMz5iPyhhW2JdPDAmJihhW2JdPTApLGFbYl0+MjU1JiYoYVtiXT0yNTUpKTozPT09YiYmKGFbYl08MCYmKGFbYl09MCksYVtiXT4xJiYoYVtiXT0xKSk7cmV0dXJuIGF9LGQ9TWF0aC5QSSxwYT1NYXRoLnJvdW5kLHc9TWF0aC5jb3MsQj1NYXRoLmZsb29yLF89TWF0aC5wb3csVD1NYXRoLmxvZyxyYT1NYXRoLnNpbixzYT1NYXRoLnNxcnQsbT1NYXRoLmF0YW4yLFc9TWF0aC5tYXgsbD1NYXRoLmFicyxnPTIqZCxlPWQvMyxiPWQvMTgwLGY9MTgwL2Qscz1mdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGE/YXJndW1lbnRzWzBdOmZ1bmN0aW9uKGEsYixjKXtjLnByb3RvdHlwZT1hLnByb3RvdHlwZTt2YXIgZD1uZXcgYyxlPWEuYXBwbHkoZCxiKTtyZXR1cm4gT2JqZWN0KGUpPT09ZT9lOmR9KGEsYXJndW1lbnRzLGZ1bmN0aW9uKCl7fSl9LGs9W10sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbnVsbCE9PW1vZHVsZSYmbnVsbCE9bW9kdWxlLmV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz1zKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGZ1bmN0aW9uKCl7cmV0dXJuIHN9KToob2E9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHMmJm51bGwhPT1leHBvcnRzP2V4cG9ydHM6dGhpcyxvYS5jaHJvbWE9cykscy52ZXJzaW9uPVwiMS4xLjFcIixqPXt9LGg9W10saT0hMSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3ZhciBhLGIsYyxkLGUsZixnLGssbDtmb3IoZj10aGlzLGI9W10saz0wLGQ9YXJndW1lbnRzLmxlbmd0aDtkPms7aysrKWE9YXJndW1lbnRzW2tdLG51bGwhPWEmJmIucHVzaChhKTtpZihnPWJbYi5sZW5ndGgtMV0sbnVsbCE9altnXSlmLl9yZ2I9dChqW2ddKHZhKGIuc2xpY2UoMCwtMSkpKSk7ZWxzZXtmb3IoaXx8KGg9aC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIucC1hLnB9KSxpPSEwKSxsPTAsZT1oLmxlbmd0aDtlPmwmJihjPWhbbF0sIShnPWMudGVzdC5hcHBseShjLGIpKSk7bCsrKTtnJiYoZi5fcmdiPXQoaltnXS5hcHBseShqLGIpKSl9bnVsbD09Zi5fcmdiJiZjb25zb2xlLndhcm4oXCJ1bmtub3duIGZvcm1hdDogXCIrYiksbnVsbD09Zi5fcmdiJiYoZi5fcmdiPVswLDAsMF0pLDM9PT1mLl9yZ2IubGVuZ3RoJiZmLl9yZ2IucHVzaCgxKX1yZXR1cm4gYS5wcm90b3R5cGUuYWxwaGE9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JnYlszXT1hLHRoaXMpOnRoaXMuX3JnYlszXX0sYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lKCl9LGF9KCkscy5faW5wdXQ9aixzLmJyZXdlcj1xPXtPclJkOltcIiNmZmY3ZWNcIixcIiNmZWU4YzhcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiNiMzAwMDBcIixcIiM3ZjAwMDBcIl0sUHVCdTpbXCIjZmZmN2ZiXCIsXCIjZWNlN2YyXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDQ1YThkXCIsXCIjMDIzODU4XCJdLEJ1UHU6W1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzgxMGY3Y1wiLFwiIzRkMDA0YlwiXSxPcmFuZ2VzOltcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiNhNjM2MDNcIixcIiM3ZjI3MDRcIl0sQnVHbjpbXCIjZjdmY2ZkXCIsXCIjZTVmNWY5XCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdLFlsT3JCcjpbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOTkzNDA0XCIsXCIjNjYyNTA2XCJdLFlsR246W1wiI2ZmZmZlNVwiLFwiI2Y3ZmNiOVwiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNjgzN1wiLFwiIzAwNDUyOVwiXSxSZWRzOltcIiNmZmY1ZjBcIixcIiNmZWUwZDJcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiNhNTBmMTVcIixcIiM2NzAwMGRcIl0sUmRQdTpbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCIsXCIjNDkwMDZhXCJdLEdyZWVuczpbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdLFlsR25CdTpbXCIjZmZmZmQ5XCIsXCIjZWRmOGIxXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMjUzNDk0XCIsXCIjMDgxZDU4XCJdLFB1cnBsZXM6W1wiI2ZjZmJmZFwiLFwiI2VmZWRmNVwiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzU0Mjc4ZlwiLFwiIzNmMDA3ZFwiXSxHbkJ1OltcIiNmN2ZjZjBcIixcIiNlMGYzZGJcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODY4YWNcIixcIiMwODQwODFcIl0sR3JleXM6W1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiLFwiIzAwMDAwMFwiXSxZbE9yUmQ6W1wiI2ZmZmZjY1wiLFwiI2ZmZWRhMFwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2JkMDAyNlwiLFwiIzgwMDAyNlwiXSxQdVJkOltcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5ODAwNDNcIixcIiM2NzAwMWZcIl0sQmx1ZXM6W1wiI2Y3ZmJmZlwiLFwiI2RlZWJmN1wiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NTE5Y1wiLFwiIzA4MzA2YlwiXSxQdUJ1R246W1wiI2ZmZjdmYlwiLFwiI2VjZTJmMFwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNmM1OVwiLFwiIzAxNDYzNlwiXSxTcGVjdHJhbDpbXCIjOWUwMTQyXCIsXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCIsXCIjNWU0ZmEyXCJdLFJkWWxHbjpbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCIsXCIjMDA2ODM3XCJdLFJkQnU6W1wiIzY3MDAxZlwiLFwiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiLFwiIzA1MzA2MVwiXSxQaVlHOltcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl0sUFJHbjpbXCIjNDAwMDRiXCIsXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZjdmN2Y3XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCIsXCIjMDA0NDFiXCJdLFJkWWxCdTpbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCIsXCIjMzEzNjk1XCJdLEJyQkc6W1wiIzU0MzAwNVwiLFwiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiLFwiIzAwM2MzMFwiXSxSZEd5OltcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl0sUHVPcjpbXCIjN2YzYjA4XCIsXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZjdmN2Y3XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCIsXCIjMmQwMDRiXCJdLFNldDI6W1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiLFwiI2U1YzQ5NFwiLFwiI2IzYjNiM1wiXSxBY2NlbnQ6W1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiLFwiI2JmNWIxN1wiLFwiIzY2NjY2NlwiXSxTZXQxOltcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIixcIiM5OTk5OTlcIl0sU2V0MzpbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCIsXCIjZmZlZDZmXCJdLERhcmsyOltcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIixcIiM2NjY2NjZcIl0sUGFpcmVkOltcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIixcIiNmZmZmOTlcIixcIiNiMTU5MjhcIl0sUGFzdGVsMjpbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCIsXCIjY2NjY2NjXCJdLFBhc3RlbDE6W1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiLFwiI2ZkZGFlY1wiLFwiI2YyZjJmMlwiXX0sd2E9e2luZGlnbzpcIiM0YjAwODJcIixnb2xkOlwiI2ZmZDcwMFwiLGhvdHBpbms6XCIjZmY2OWI0XCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIix5ZWxsb3c6XCIjZmZmZjAwXCIsbWlzdHlyb3NlOlwiI2ZmZTRlMVwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLG9saXZlOlwiIzgwODAwMFwiLGRhcmtzZWFncmVlbjpcIiM4ZmJjOGZcIixwaW5rOlwiI2ZmYzBjYlwiLHRvbWF0bzpcIiNmZjYzNDdcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixuYXZham93aGl0ZTpcIiNmZmRlYWRcIixsaW1lOlwiIzAwZmYwMFwiLHBhbGVncmVlbjpcIiM5OGZiOThcIixkYXJrc2xhdGVncmV5OlwiIzJmNGY0ZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixzZWFzaGVsbDpcIiNmZmY1ZWVcIixtZWRpdW1zcHJpbmdncmVlbjpcIiMwMGZhOWFcIixmdWNoc2lhOlwiI2ZmMDBmZlwiLHBhcGF5YXdoaXA6XCIjZmZlZmQ1XCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixkaW1ncmF5OlwiIzY5Njk2OVwiLGJsYWNrOlwiIzAwMDAwMFwiLHBlYWNocHVmZjpcIiNmZmRhYjlcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLHdoaXRlOlwiI2ZmZmZmZlwiLG9yYW5nZTpcIiNmZmE1MDBcIixsaWdodHNhbG1vbjpcIiNmZmEwN2FcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGJyb3duOlwiI2E1MmEyYVwiLGl2b3J5OlwiI2ZmZmZmMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIscGVydTpcIiNjZDg1M2ZcIixsYXduZ3JlZW46XCIjN2NmYzAwXCIsY2hvY29sYXRlOlwiI2QyNjkxZVwiLGNyaW1zb246XCIjZGMxNDNjXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIsbGlnaHRzZWFncmVlbjpcIiMyMGIyYWFcIixjeWFuOlwiIzAwZmZmZlwiLG1pbnRjcmVhbTpcIiNmNWZmZmFcIixzaWx2ZXI6XCIjYzBjMGMwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLG1lZGl1bW9yY2hpZDpcIiNiYTU1ZDNcIixza3libHVlOlwiIzg3Y2VlYlwiLGdyYXk6XCIjODA4MDgwXCIsZGFya3R1cnF1b2lzZTpcIiMwMGNlZDFcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZGFya2dyZWVuOlwiIzAwNjQwMFwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGRhcmt2aW9sZXQ6XCIjOTQwMGQzXCIsZGFya2dyYXk6XCIjYTlhOWE5XCIsbW9jY2FzaW46XCIjZmZlNGI1XCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsZ3JleTpcIiM4MDgwODBcIixkYXJrc2xhdGVibHVlOlwiIzQ4M2Q4YlwiLGxpZ2h0c2t5Ymx1ZTpcIiM4N2NlZmFcIixsaWdodHBpbms6XCIjZmZiNmMxXCIsbWVkaXVtdmlvbGV0cmVkOlwiI2M3MTU4NVwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixyZWQ6XCIjZmYwMDAwXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsbGltZWdyZWVuOlwiIzMyY2QzMlwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLHBhbGVnb2xkZW5yb2Q6XCIjZWVlOGFhXCIscGx1bTpcIiNkZGEwZGRcIix0dXJxdW9pc2U6XCIjNDBlMGQwXCIsbGlnaHRncmV5OlwiI2QzZDNkM1wiLGxpZ2h0Z29sZGVucm9keWVsbG93OlwiI2ZhZmFkMlwiLGRhcmtnb2xkZW5yb2Q6XCIjYjg4NjBiXCIsbGF2ZW5kZXI6XCIjZTZlNmZhXCIsbWFyb29uOlwiIzgwMDAwMFwiLHllbGxvd2dyZWVuOlwiIzlhY2QzMlwiLHNhbmR5YnJvd246XCIjZjRhNDYwXCIsdGhpc3RsZTpcIiNkOGJmZDhcIix2aW9sZXQ6XCIjZWU4MmVlXCIsbmF2eTpcIiMwMDAwODBcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGRpbWdyZXk6XCIjNjk2OTY5XCIsdGFuOlwiI2QyYjQ4Y1wiLHJvc3licm93bjpcIiNiYzhmOGZcIixvbGl2ZWRyYWI6XCIjNmI4ZTIzXCIsYmx1ZTpcIiMwMDAwZmZcIixsaWdodGJsdWU6XCIjYWRkOGU2XCIsZ2hvc3R3aGl0ZTpcIiNmOGY4ZmZcIixob25leWRldzpcIiNmMGZmZjBcIixjb3JuZmxvd2VyYmx1ZTpcIiM2NDk1ZWRcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGluZW46XCIjZmFmMGU2XCIsZGFya2JsdWU6XCIjMDAwMDhiXCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixzZWFncmVlbjpcIiMyZThiNTdcIixkYXJra2hha2k6XCIjYmRiNzZiXCIsc25vdzpcIiNmZmZhZmFcIixzaWVubmE6XCIjYTA1MjJkXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixyb3lhbGJsdWU6XCIjNDE2OWUxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGdyZWVuOlwiIzAwODAwMFwiLG1lZGl1bXB1cnBsZTpcIiM5MzcwZGJcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsY29ybnNpbGs6XCIjZmZmOGRjXCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixiaXNxdWU6XCIjZmZlNGM0XCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLGRhcmtjeWFuOlwiIzAwOGI4YlwiLGtoYWtpOlwiI2YwZTY4Y1wiLHdoZWF0OlwiI2Y1ZGViM1wiLHRlYWw6XCIjMDA4MDgwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkZWVwc2t5Ymx1ZTpcIiMwMGJmZmZcIixzYWxtb246XCIjZmE4MDcyXCIsZGFya3JlZDpcIiM4YjAwMDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscGFsZXZpb2xldHJlZDpcIiNkYjcwOTNcIixsaWdodHNsYXRlZ3JheTpcIiM3Nzg4OTlcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbGlnaHRncmVlbjpcIiM5MGVlOTBcIixvcmNoaWQ6XCIjZGE3MGQ2XCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLG1lZGl1bXNlYWdyZWVuOlwiIzNjYjM3MVwiLGxpZ2h0Z3JheTpcIiNkM2QzZDNcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbGVtb25jaGlmZm9uOlwiI2ZmZmFjZFwiLGNhZGV0Ymx1ZTpcIiM1ZjllYTBcIixsaWdodHllbGxvdzpcIiNmZmZmZTBcIixsYXZlbmRlcmJsdXNoOlwiI2ZmZjBmNVwiLGNvcmFsOlwiI2ZmN2Y1MFwiLHB1cnBsZTpcIiM4MDAwODBcIixhcXVhOlwiIzAwZmZmZlwiLHdoaXRlc21va2U6XCIjZjVmNWY1XCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLGRhcmtvcmFuZ2U6XCIjZmY4YzAwXCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixkYXJrc2FsbW9uOlwiI2U5OTY3YVwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsYXp1cmU6XCIjZjBmZmZmXCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsb2xkbGFjZTpcIiNmZGY1ZTZcIixyZWJlY2NhcHVycGxlOlwiIzY2MzM5OVwifSxzLmNvbG9ycz12PXdhLE49ZnVuY3Rpb24oKXt2YXIgYSxiLGQsZSxmLGcsaCxpLGo7cmV0dXJuIGI9dmEoYXJndW1lbnRzKSxmPWJbMF0sYT1iWzFdLGQ9YlsyXSxpPShmKzE2KS8xMTYsaD1pc05hTihhKT9pOmkrYS81MDAsaj1pc05hTihkKT9pOmktZC8yMDAsaT1jLlluKk8oaSksaD1jLlhuKk8oaCksaj1jLlpuKk8oaiksZz15YSgzLjI0MDQ1NDIqaC0xLjUzNzEzODUqaS0uNDk4NTMxNCpqKSxlPXlhKC0uOTY5MjY2KmgrMS44NzYwMTA4KmkrLjA0MTU1NipqKSxkPXlhKC4wNTU2NDM0KmgtLjIwNDAyNTkqaSsxLjA1NzIyNTIqaiksZz1TKGcsMCwyNTUpLGU9UyhlLDAsMjU1KSxkPVMoZCwwLDI1NSksW2csZSxkLGIubGVuZ3RoPjM/YlszXToxXX0seWE9ZnVuY3Rpb24oYSl7cmV0dXJuIHBhKDI1NSooLjAwMzA0Pj1hPzEyLjkyKmE6MS4wNTUqXyhhLDEvMi40KS0uMDU1KSl9LE89ZnVuY3Rpb24oYSl7cmV0dXJuIGE+Yy50MT9hKmEqYTpjLnQyKihhLWMudDApfSxjPXtLbjoxOCxYbjouOTUwNDcsWW46MSxabjoxLjA4ODgzLHQwOi4xMzc5MzEwMzQsdDE6LjIwNjg5NjU1Mix0MjouMTI4NDE4NTUsdDM6LjAwODg1NjQ1Mn0sZ2E9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoO3JldHVybiBkPXZhKGFyZ3VtZW50cyksYz1kWzBdLGI9ZFsxXSxhPWRbMl0sZT1sYShjLGIsYSksZj1lWzBdLGc9ZVsxXSxoPWVbMl0sWzExNipnLTE2LDUwMCooZi1nKSwyMDAqKGctaCldfSxtYT1mdW5jdGlvbihhKXtyZXR1cm4oYS89MjU1KTw9LjA0MDQ1P2EvMTIuOTI6XygoYSsuMDU1KS8xLjA1NSwyLjQpfSx4YT1mdW5jdGlvbihhKXtyZXR1cm4gYT5jLnQzP18oYSwxLzMpOmEvYy50MitjLnQwfSxsYT1mdW5jdGlvbigpe3ZhciBhLGIsZCxlLGYsZyxoO3JldHVybiBlPXZhKGFyZ3VtZW50cyksZD1lWzBdLGI9ZVsxXSxhPWVbMl0sZD1tYShkKSxiPW1hKGIpLGE9bWEoYSksZj14YSgoLjQxMjQ1NjQqZCsuMzU3NTc2MSpiKy4xODA0Mzc1KmEpL2MuWG4pLGc9eGEoKC4yMTI2NzI5KmQrLjcxNTE1MjIqYisuMDcyMTc1KmEpL2MuWW4pLGg9eGEoKC4wMTkzMzM5KmQrLjExOTE5MipiKy45NTAzMDQxKmEpL2MuWm4pLFtmLGcsaF19LHMubGFiPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsYixjKXtjLnByb3RvdHlwZT1hLnByb3RvdHlwZTt2YXIgZD1uZXcgYyxlPWEuYXBwbHkoZCxiKTtyZXR1cm4gT2JqZWN0KGUpPT09ZT9lOmR9KGEsemEuY2FsbChhcmd1bWVudHMpLmNvbmNhdChbXCJsYWJcIl0pLGZ1bmN0aW9uKCl7fSl9LGoubGFiPU4sYS5wcm90b3R5cGUubGFiPWZ1bmN0aW9uKCl7cmV0dXJuIGdhKHRoaXMuX3JnYil9LG49ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaSxqLGssbDtyZXR1cm4gYT1mdW5jdGlvbigpe3ZhciBiLGMsZDtmb3IoZD1bXSxjPTAsYj1hLmxlbmd0aDtiPmM7YysrKWU9YVtjXSxkLnB1c2gocyhlKSk7cmV0dXJuIGR9KCksMj09PWEubGVuZ3RoPyhqPWZ1bmN0aW9uKCl7dmFyIGIsYyxkO2ZvcihkPVtdLGM9MCxiPWEubGVuZ3RoO2I+YztjKyspZT1hW2NdLGQucHVzaChlLmxhYigpKTtyZXR1cm4gZH0oKSxmPWpbMF0sZz1qWzFdLGI9ZnVuY3Rpb24oYSl7dmFyIGIsYztyZXR1cm4gYz1mdW5jdGlvbigpe3ZhciBjLGQ7Zm9yKGQ9W10sYj1jPTA7Mj49YztiPSsrYylkLnB1c2goZltiXSthKihnW2JdLWZbYl0pKTtyZXR1cm4gZH0oKSxzLmxhYi5hcHBseShzLGMpfSk6Mz09PWEubGVuZ3RoPyhrPWZ1bmN0aW9uKCl7dmFyIGIsYyxkO2ZvcihkPVtdLGM9MCxiPWEubGVuZ3RoO2I+YztjKyspZT1hW2NdLGQucHVzaChlLmxhYigpKTtyZXR1cm4gZH0oKSxmPWtbMF0sZz1rWzFdLGg9a1syXSxiPWZ1bmN0aW9uKGEpe3ZhciBiLGM7cmV0dXJuIGM9ZnVuY3Rpb24oKXt2YXIgYyxkO2ZvcihkPVtdLGI9Yz0wOzI+PWM7Yj0rK2MpZC5wdXNoKCgxLWEpKigxLWEpKmZbYl0rMiooMS1hKSphKmdbYl0rYSphKmhbYl0pO3JldHVybiBkfSgpLHMubGFiLmFwcGx5KHMsYyl9KTo0PT09YS5sZW5ndGg/KGw9ZnVuY3Rpb24oKXt2YXIgYixjLGQ7Zm9yKGQ9W10sYz0wLGI9YS5sZW5ndGg7Yj5jO2MrKyllPWFbY10sZC5wdXNoKGUubGFiKCkpO3JldHVybiBkfSgpLGY9bFswXSxnPWxbMV0saD1sWzJdLGk9bFszXSxiPWZ1bmN0aW9uKGEpe3ZhciBiLGM7cmV0dXJuIGM9ZnVuY3Rpb24oKXt2YXIgYyxkO2ZvcihkPVtdLGI9Yz0wOzI+PWM7Yj0rK2MpZC5wdXNoKCgxLWEpKigxLWEpKigxLWEpKmZbYl0rMyooMS1hKSooMS1hKSphKmdbYl0rMyooMS1hKSphKmEqaFtiXSthKmEqYSppW2JdKTtyZXR1cm4gZH0oKSxzLmxhYi5hcHBseShzLGMpfSk6NT09PWEubGVuZ3RoJiYoYz1uKGEuc2xpY2UoMCwzKSksZD1uKGEuc2xpY2UoMiw1KSksYj1mdW5jdGlvbihhKXtyZXR1cm4uNT5hP2MoMiphKTpkKDIqKGEtLjUpKX0pLGJ9LHMuYmV6aWVyPWZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiBiPW4oYSksYi5zY2FsZT1mdW5jdGlvbigpe3JldHVybiBzLnNjYWxlKGIpfSxifSxzLmN1YmVoZWxpeD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGgsaTtyZXR1cm4gbnVsbD09YSYmKGE9MzAwKSxudWxsPT1iJiYoYj0tMS41KSxudWxsPT1jJiYoYz0xKSxudWxsPT1kJiYoZD0xKSxudWxsPT1lJiYoZT1bMCwxXSksaD1lWzFdLWVbMF0sZj0wLGk9ZnVuY3Rpb24oaSl7dmFyIGosayxsLG0sbixvLHAscSxyO3JldHVybiBqPWcqKChhKzEyMCkvMzYwK2IqaSkscD1fKGVbMF0raCppLGQpLG89MCE9PWY/Y1swXStpKmY6YyxrPW8qcCooMS1wKS8yLG09dyhqKSxyPXJhKGopLHE9cCtrKigtLjE0ODYxKm0rMS43ODI3NypyKSxuPXArayooLS4yOTIyNyptLS45MDY0OSpyKSxsPXArMS45NzI5NCprKm0scyh0KFsyNTUqcSwyNTUqbiwyNTUqbF0pKX0saS5zdGFydD1mdW5jdGlvbihiKXtyZXR1cm4gbnVsbD09Yj9hOihhPWIsaSl9LGkucm90YXRpb25zPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2I6KGI9YSxpKX0saS5nYW1tYT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT9kOihkPWEsaSl9LGkuaHVlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2M6KGM9YSxcImFycmF5XCI9PT11YShjKT8oZj1jWzFdLWNbMF0sMD09PWYmJihjPWNbMV0pKTpmPTAsaSl9LGkubGlnaHRuZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2U6KGU9YSxcImFycmF5XCI9PT11YShlKT8oaD1lWzFdLWVbMF0sMD09PWgmJihlPWVbMV0pKTpoPTAsaSl9LGkuc2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gcy5zY2FsZShpKX0saS5odWUoYyksaX0scy5yYW5kb209ZnVuY3Rpb24oKXt2YXIgYixjLGQsZTtmb3IoYz1cIjAxMjM0NTY3ODlhYmNkZWZcIixiPVwiI1wiLGQ9ZT0wOzY+ZTtkPSsrZSliKz1jLmNoYXJBdChCKDE2Kk1hdGgucmFuZG9tKCkpKTtyZXR1cm4gbmV3IGEoYil9LGoucmdiPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7Yj12YShhcmd1bWVudHMpLGM9W107Zm9yKGEgaW4gYilkPWJbYV0sYy5wdXNoKGQpO3JldHVybiBjfSxzLnJnYj1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhLGIsYyl7Yy5wcm90b3R5cGU9YS5wcm90b3R5cGU7dmFyIGQ9bmV3IGMsZT1hLmFwcGx5KGQsYik7cmV0dXJuIE9iamVjdChlKT09PWU/ZTpkfShhLHphLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoW1wicmdiXCJdKSxmdW5jdGlvbigpe30pfSxhLnByb3RvdHlwZS5yZ2I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsMyl9LGEucHJvdG90eXBlLnJnYmE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmdifSxoLnB1c2goe3A6MTUsdGVzdDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gYj12YShhcmd1bWVudHMpLFwiYXJyYXlcIj09PXVhKGIpJiYzPT09Yi5sZW5ndGg/XCJyZ2JcIjo0PT09Yi5sZW5ndGgmJlwibnVtYmVyXCI9PT11YShiWzNdKSYmYlszXT49MCYmYlszXTw9MT9cInJnYlwiOnZvaWQgMH19KSxDPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZztpZihhLm1hdGNoKC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC8pKXJldHVybig0PT09YS5sZW5ndGh8fDc9PT1hLmxlbmd0aCkmJihhPWEuc3Vic3RyKDEpKSwzPT09YS5sZW5ndGgmJihhPWEuc3BsaXQoXCJcIiksYT1hWzBdK2FbMF0rYVsxXSthWzFdK2FbMl0rYVsyXSksZz1wYXJzZUludChhLDE2KSxlPWc+PjE2LGQ9Zz4+OCYyNTUsYz0yNTUmZyxbZSxkLGMsMV07aWYoYS5tYXRjaCgvXiM/KFtBLUZhLWYwLTldezh9KSQvKSlyZXR1cm4gOT09PWEubGVuZ3RoJiYoYT1hLnN1YnN0cigxKSksZz1wYXJzZUludChhLDE2KSxlPWc+PjI0JjI1NSxkPWc+PjE2JjI1NSxjPWc+PjgmMjU1LGI9cGEoKDI1NSZnKS8yNTUqMTAwKS8xMDAsW2UsZCxjLGJdO2lmKG51bGwhPWouY3NzJiYoZj1qLmNzcyhhKSkpcmV0dXJuIGY7dGhyb3dcInVua25vd24gY29sb3I6IFwiK2F9LGNhPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoLGk7cmV0dXJuIG51bGw9PWImJihiPVwicmdiXCIpLGc9YVswXSxlPWFbMV0sZD1hWzJdLGM9YVszXSxpPWc8PDE2fGU8PDh8ZCxoPVwiMDAwMDAwXCIraS50b1N0cmluZygxNiksaD1oLnN1YnN0cihoLmxlbmd0aC02KSxmPVwiMFwiK3BhKDI1NSpjKS50b1N0cmluZygxNiksZj1mLnN1YnN0cihmLmxlbmd0aC0yKSxcIiNcIitmdW5jdGlvbigpe3N3aXRjaChiLnRvTG93ZXJDYXNlKCkpe2Nhc2VcInJnYmFcIjpyZXR1cm4gaCtmO2Nhc2VcImFyZ2JcIjpyZXR1cm4gZitoO2RlZmF1bHQ6cmV0dXJuIGh9fSgpfSxqLmhleD1mdW5jdGlvbihhKXtyZXR1cm4gQyhhKX0scy5oZXg9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2MucHJvdG90eXBlPWEucHJvdG90eXBlO3ZhciBkPW5ldyBjLGU9YS5hcHBseShkLGIpO3JldHVybiBPYmplY3QoZSk9PT1lP2U6ZH0oYSx6YS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KFtcImhleFwiXSksZnVuY3Rpb24oKXt9KX0sYS5wcm90b3R5cGUuaGV4PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiYoYT1cInJnYlwiKSxjYSh0aGlzLl9yZ2IsYSl9LGgucHVzaCh7cDoxMCx0ZXN0OmZ1bmN0aW9uKGEpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aCYmXCJzdHJpbmdcIj09PXVhKGEpP1wiaGV4XCI6dm9pZCAwfX0pLEY9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuO2lmKGE9dmEoYXJndW1lbnRzKSxlPWFbMF0saz1hWzFdLGc9YVsyXSwwPT09aylpPWQ9Yj0yNTUqZztlbHNle2ZvcihuPVswLDAsMF0sYz1bMCwwLDBdLG09LjU+Zz9nKigxK2spOmcray1nKmssbD0yKmctbSxlLz0zNjAsblswXT1lKzEvMyxuWzFdPWUsblsyXT1lLTEvMyxmPWg9MDsyPj1oO2Y9KytoKW5bZl08MCYmKG5bZl0rPTEpLG5bZl0+MSYmKG5bZl0tPTEpLDYqbltmXTwxP2NbZl09bCs2KihtLWwpKm5bZl06MipuW2ZdPDE/Y1tmXT1tOjMqbltmXTwyP2NbZl09bCsobS1sKSooMi8zLW5bZl0pKjY6Y1tmXT1sO2o9W3BhKDI1NSpjWzBdKSxwYSgyNTUqY1sxXSkscGEoMjU1KmNbMl0pXSxpPWpbMF0sZD1qWzFdLGI9alsyXX1yZXR1cm4gYS5sZW5ndGg+Mz9baSxkLGIsYVszXV06W2ksZCxiXX0sZWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg7cmV0dXJuIHZvaWQgMCE9PWEmJmEubGVuZ3RoPj0zJiYoZz1hLGE9Z1swXSxiPWdbMV0sYz1nWzJdKSxhLz0yNTUsYi89MjU1LGMvPTI1NSxmPU1hdGgubWluKGEsYixjKSxXPU1hdGgubWF4KGEsYixjKSxlPShXK2YpLzIsVz09PWY/KGg9MCxkPU51bWJlci5OYU4pOmg9LjU+ZT8oVy1mKS8oVytmKTooVy1mKS8oMi1XLWYpLGE9PT1XP2Q9KGItYykvKFctZik6Yj09PVc/ZD0yKyhjLWEpLyhXLWYpOmM9PT1XJiYoZD00KyhhLWIpLyhXLWYpKSxkKj02MCwwPmQmJihkKz0zNjApLFtkLGgsZV19LHMuaHNsPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsYixjKXtjLnByb3RvdHlwZT1hLnByb3RvdHlwZTt2YXIgZD1uZXcgYyxlPWEuYXBwbHkoZCxiKTtyZXR1cm4gT2JqZWN0KGUpPT09ZT9lOmR9KGEsemEuY2FsbChhcmd1bWVudHMpLmNvbmNhdChbXCJoc2xcIl0pLGZ1bmN0aW9uKCl7fSl9LGouaHNsPUYsYS5wcm90b3R5cGUuaHNsPWZ1bmN0aW9uKCl7cmV0dXJuIGVhKHRoaXMuX3JnYil9LEc9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHI7aWYoYT12YShhcmd1bWVudHMpLGU9YVswXSxwPWFbMV0scj1hWzJdLHIqPTI1NSwwPT09cClpPWQ9Yj1yO2Vsc2Ugc3dpdGNoKDM2MD09PWUmJihlPTApLGU+MzYwJiYoZS09MzYwKSwwPmUmJihlKz0zNjApLGUvPTYwLGY9QihlKSxjPWUtZixnPXIqKDEtcCksaD1yKigxLXAqYykscT1yKigxLXAqKDEtYykpLGYpe2Nhc2UgMDpqPVtyLHEsZ10saT1qWzBdLGQ9alsxXSxiPWpbMl07YnJlYWs7Y2FzZSAxOms9W2gscixnXSxpPWtbMF0sZD1rWzFdLGI9a1syXTticmVhaztjYXNlIDI6bD1bZyxyLHFdLGk9bFswXSxkPWxbMV0sYj1sWzJdO2JyZWFrO2Nhc2UgMzptPVtnLGgscl0saT1tWzBdLGQ9bVsxXSxiPW1bMl07YnJlYWs7Y2FzZSA0Om49W3EsZyxyXSxpPW5bMF0sZD1uWzFdLGI9blsyXTticmVhaztjYXNlIDU6bz1bcixnLGhdLGk9b1swXSxkPW9bMV0sYj1vWzJdfXJldHVybiBpPXBhKGkpLGQ9cGEoZCksYj1wYShiKSxbaSxkLGIsYS5sZW5ndGg+Mz9hWzNdOjFdfSxmYT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkLGUsZixnLGgsaTtyZXR1cm4gZz12YShhcmd1bWVudHMpLGY9Z1swXSxjPWdbMV0sYT1nWzJdLGU9TWF0aC5taW4oZixjLGEpLFc9TWF0aC5tYXgoZixjLGEpLGI9Vy1lLGk9Vy8yNTUsMD09PVc/KGQ9TnVtYmVyLk5hTixoPTApOihoPWIvVyxmPT09VyYmKGQ9KGMtYSkvYiksYz09PVcmJihkPTIrKGEtZikvYiksYT09PVcmJihkPTQrKGYtYykvYiksZCo9NjAsMD5kJiYoZCs9MzYwKSksW2QsaCxpXX0scy5oc3Y9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2MucHJvdG90eXBlPWEucHJvdG90eXBlO3ZhciBkPW5ldyBjLGU9YS5hcHBseShkLGIpO3JldHVybiBPYmplY3QoZSk9PT1lP2U6ZH0oYSx6YS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KFtcImhzdlwiXSksZnVuY3Rpb24oKXt9KX0sai5oc3Y9RyxhLnByb3RvdHlwZS5oc3Y9ZnVuY3Rpb24oKXtyZXR1cm4gZmEodGhpcy5fcmdiKX0sWj1mdW5jdGlvbihhKXt2YXIgYixjLGQ7cmV0dXJuXCJudW1iZXJcIj09PXVhKGEpJiZhPj0wJiYxNjc3NzIxNT49YT8oZD1hPj4xNixjPWE+PjgmMjU1LGI9MjU1JmEsW2QsYyxiLDFdKTooY29uc29sZS53YXJuKFwidW5rbm93biBudW0gY29sb3I6IFwiK2EpLFswLDAsMCwxXSl9LGphPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7cmV0dXJuIGQ9dmEoYXJndW1lbnRzKSxjPWRbMF0sYj1kWzFdLGE9ZFsyXSwoYzw8MTYpKyhiPDw4KSthfSxzLm51bT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEoYixcIm51bVwiKX0sYS5wcm90b3R5cGUubnVtPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiYoYT1cInJnYlwiKSxqYSh0aGlzLl9yZ2IsYSl9LGoubnVtPVosaC5wdXNoKHtwOjEwLHRlc3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT09dWEoYSkmJmE+PTAmJjE2Nzc3MjE1Pj1hP1wibnVtXCI6dm9pZCAwfX0pLHg9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaTtpZihhPWEudG9Mb3dlckNhc2UoKSxudWxsIT1zLmNvbG9ycyYmcy5jb2xvcnNbYV0pcmV0dXJuIEMocy5jb2xvcnNbYV0pO2lmKGY9YS5tYXRjaCgvcmdiXFwoXFxzKihcXC0/XFxkKyksXFxzKihcXC0/XFxkKylcXHMqLFxccyooXFwtP1xcZCspXFxzKlxcKS8pKXtmb3IoaD1mLnNsaWNlKDEsNCksZT1nPTA7Mj49ZztlPSsrZyloW2VdPStoW2VdO2hbM109MX1lbHNlIGlmKGY9YS5tYXRjaCgvcmdiYVxcKFxccyooXFwtP1xcZCspLFxccyooXFwtP1xcZCspXFxzKixcXHMqKFxcLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkvKSlmb3IoaD1mLnNsaWNlKDEsNSksZT1pPTA7Mz49aTtlPSsraSloW2VdPStoW2VdO2Vsc2UgaWYoZj1hLm1hdGNoKC9yZ2JcXChcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKihcXC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpLykpe2ZvcihoPWYuc2xpY2UoMSw0KSxlPWI9MDsyPj1iO2U9KytiKWhbZV09cGEoMi41NSpoW2VdKTtoWzNdPTF9ZWxzZSBpZihmPWEubWF0Y2goL3JnYmFcXChcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKihcXC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpLykpe2ZvcihoPWYuc2xpY2UoMSw1KSxlPWM9MDsyPj1jO2U9KytjKWhbZV09cGEoMi41NSpoW2VdKTtoWzNdPStoWzNdfWVsc2UoZj1hLm1hdGNoKC9oc2xcXChcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSxcXHMqKFxcLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooXFwtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkvKSk/KGQ9Zi5zbGljZSgxLDQpLGRbMV0qPS4wMSxkWzJdKj0uMDEsaD1GKGQpLGhbM109MSk6KGY9YS5tYXRjaCgvaHNsYVxcKFxccyooXFwtP1xcZCsoPzpcXC5cXGQrKT8pLFxccyooXFwtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihcXC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKS8pKSYmKGQ9Zi5zbGljZSgxLDQpLGRbMV0qPS4wMSxkWzJdKj0uMDEsaD1GKGQpLGhbM109K2ZbNF0pO3JldHVybiBofSxiYT1mdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gYj1hWzNdPDE/XCJyZ2JhXCI6XCJyZ2JcIixcInJnYlwiPT09Yj9iK1wiKFwiK2Euc2xpY2UoMCwzKS5tYXAocGEpLmpvaW4oXCIsXCIpK1wiKVwiOlwicmdiYVwiPT09Yj9iK1wiKFwiK2Euc2xpY2UoMCwzKS5tYXAocGEpLmpvaW4oXCIsXCIpK1wiLFwiK2FbM10rXCIpXCI6dm9pZCAwfSxuYT1mdW5jdGlvbihhKXtyZXR1cm4gcGEoMTAwKmEpLzEwMH0sRT1mdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBjPTE+Yj9cImhzbGFcIjpcImhzbFwiLGFbMF09bmEoYVswXXx8MCksYVsxXT1uYSgxMDAqYVsxXSkrXCIlXCIsYVsyXT1uYSgxMDAqYVsyXSkrXCIlXCIsXCJoc2xhXCI9PT1jJiYoYVszXT1iKSxjK1wiKFwiK2Euam9pbihcIixcIikrXCIpXCJ9LGouY3NzPWZ1bmN0aW9uKGEpe3JldHVybiB4KGEpfSxzLmNzcz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhLGIsYyl7Yy5wcm90b3R5cGU9YS5wcm90b3R5cGU7dmFyIGQ9bmV3IGMsZT1hLmFwcGx5KGQsYik7cmV0dXJuIE9iamVjdChlKT09PWU/ZTpkfShhLHphLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoW1wiY3NzXCJdKSxmdW5jdGlvbigpe30pfSxhLnByb3RvdHlwZS5jc3M9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEmJihhPVwicmdiXCIpLFwicmdiXCI9PT1hLnNsaWNlKDAsMyk/YmEodGhpcy5fcmdiKTpcImhzbFwiPT09YS5zbGljZSgwLDMpP0UodGhpcy5oc2woKSx0aGlzLmFscGhhKCkpOnZvaWQgMH0sai5uYW1lZD1mdW5jdGlvbihhKXtyZXR1cm4gQyh3YVthXSl9LGgucHVzaCh7cDoyMCx0ZXN0OmZ1bmN0aW9uKGEpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aCYmbnVsbCE9d2FbYV0/XCJuYW1lZFwiOnZvaWQgMH19KSxhLnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKGEpe3ZhciBiLGM7YXJndW1lbnRzLmxlbmd0aCYmKHdhW2FdJiYodGhpcy5fcmdiPUMod2FbYV0pKSx0aGlzLl9yZ2JbM109MSksYj10aGlzLmhleCgpO2ZvcihjIGluIHdhKWlmKGI9PT13YVtjXSlyZXR1cm4gYztyZXR1cm4gYn0sUD1mdW5jdGlvbigpe3ZhciBhLGMsZCxlO3JldHVybiBlPXZhKGFyZ3VtZW50cyksZD1lWzBdLGE9ZVsxXSxjPWVbMl0sYyo9YixbZCx3KGMpKmEscmEoYykqYV19LFE9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrO3JldHVybiBjPXZhKGFyZ3VtZW50cyksaD1jWzBdLGU9Y1sxXSxnPWNbMl0saj1QKGgsZSxnKSxhPWpbMF0sYj1qWzFdLGQ9alsyXSxrPU4oYSxiLGQpLGk9a1swXSxmPWtbMV0sZD1rWzJdLFtTKGksMCwyNTUpLFMoZiwwLDI1NSksUyhkLDAsMjU1KSxjLmxlbmd0aD4zP2NbM106MV19LE09ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGc7cmV0dXJuIGc9dmEoYXJndW1lbnRzKSxlPWdbMF0sYT1nWzFdLGI9Z1syXSxjPXNhKGEqYStiKmIpLGQ9KG0oYixhKSpmKzM2MCklMzYwLDA9PT1wYSgxZTQqYykmJihkPU51bWJlci5OYU4pLFtlLGMsZF19LGhhPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGc7cmV0dXJuIGY9dmEoYXJndW1lbnRzKSxlPWZbMF0sYz1mWzFdLGI9ZlsyXSxnPWdhKGUsYyxiKSxkPWdbMF0sYT1nWzFdLGI9Z1syXSxNKGQsYSxiKX0scy5sY2g9ZnVuY3Rpb24oKXt2YXIgYjtyZXR1cm4gYj12YShhcmd1bWVudHMpLG5ldyBhKGIsXCJsY2hcIil9LHMuaGNsPWZ1bmN0aW9uKCl7dmFyIGI7cmV0dXJuIGI9dmEoYXJndW1lbnRzKSxuZXcgYShiLFwiaGNsXCIpfSxqLmxjaD1RLGouaGNsPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7cmV0dXJuIGQ9dmEoYXJndW1lbnRzKSxiPWRbMF0sYT1kWzFdLGM9ZFsyXSxRKFtjLGEsYl0pfSxhLnByb3RvdHlwZS5sY2g9ZnVuY3Rpb24oKXtyZXR1cm4gaGEodGhpcy5fcmdiKX0sYS5wcm90b3R5cGUuaGNsPWZ1bmN0aW9uKCl7cmV0dXJuIGhhKHRoaXMuX3JnYikucmV2ZXJzZSgpfSxhYT1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaCxpLGo7cmV0dXJuIG51bGw9PWEmJihhPVwicmdiXCIpLGk9dmEoYXJndW1lbnRzKSxoPWlbMF0sZT1pWzFdLGI9aVsyXSxoLz0yNTUsZS89MjU1LGIvPTI1NSxmPTEtTWF0aC5tYXgoaCxNYXRoLm1heChlLGIpKSxkPTE+Zj8xLygxLWYpOjAsYz0oMS1oLWYpKmQsZz0oMS1lLWYpKmQsaj0oMS1iLWYpKmQsW2MsZyxqLGZdfSx1PWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGcsaCxpO3JldHVybiBiPXZhKGFyZ3VtZW50cyksZD1iWzBdLGc9YlsxXSxpPWJbMl0sZj1iWzNdLGE9Yi5sZW5ndGg+ND9iWzRdOjEsMT09PWY/WzAsMCwwLGFdOihoPWQ+PTE/MDpwYSgyNTUqKDEtZCkqKDEtZikpLGU9Zz49MT8wOnBhKDI1NSooMS1nKSooMS1mKSksYz1pPj0xPzA6cGEoMjU1KigxLWkpKigxLWYpKSxbaCxlLGMsYV0pfSxqLmNteWs9ZnVuY3Rpb24oKXtyZXR1cm4gdSh2YShhcmd1bWVudHMpKX0scy5jbXlrPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsYixjKXtjLnByb3RvdHlwZT1hLnByb3RvdHlwZTt2YXIgZD1uZXcgYyxlPWEuYXBwbHkoZCxiKTtyZXR1cm4gT2JqZWN0KGUpPT09ZT9lOmR9KGEsemEuY2FsbChhcmd1bWVudHMpLmNvbmNhdChbXCJjbXlrXCJdKSxmdW5jdGlvbigpe30pfSxhLnByb3RvdHlwZS5jbXlrPWZ1bmN0aW9uKCl7cmV0dXJuIGFhKHRoaXMuX3JnYil9LGouZ2w9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlO2ZvcihkPWZ1bmN0aW9uKCl7dmFyIGEsYzthPXZhKGFyZ3VtZW50cyksYz1bXTtmb3IoYiBpbiBhKWU9YVtiXSxjLnB1c2goZSk7cmV0dXJuIGN9LmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhPWM9MDsyPj1jO2E9KytjKWRbYV0qPTI1NTtyZXR1cm4gZH0scy5nbD1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhLGIsYyl7Yy5wcm90b3R5cGU9YS5wcm90b3R5cGU7dmFyIGQ9bmV3IGMsZT1hLmFwcGx5KGQsYik7cmV0dXJuIE9iamVjdChlKT09PWU/ZTpkfShhLHphLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoW1wiZ2xcIl0pLGZ1bmN0aW9uKCl7fSl9LGEucHJvdG90eXBlLmdsPWZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGE9dGhpcy5fcmdiLFthWzBdLzI1NSxhWzFdLzI1NSxhWzJdLzI1NSxhWzNdXX0saWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO3JldHVybiBkPXZhKGFyZ3VtZW50cyksYT1kWzBdLGI9ZFsxXSxjPWRbMl0sYT1VKGEpLGI9VShiKSxjPVUoYyksLjIxMjYqYSsuNzE1MipiKy4wNzIyKmN9LFU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEvPTI1NSwuMDM5Mjg+PWE/YS8xMi45MjpfKChhKy4wNTUpLzEuMDU1LDIuNCl9LGs9W10sSD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGcsaDtmb3IobnVsbD09YyYmKGM9LjUpLG51bGw9PWQmJihkPVwicmdiXCIpLFwib2JqZWN0XCIhPT11YShhKSYmKGE9cyhhKSksXCJvYmplY3RcIiE9PXVhKGIpJiYoYj1zKGIpKSxnPTAsZj1rLmxlbmd0aDtmPmc7ZysrKWlmKGU9a1tnXSxkPT09ZVswXSl7aD1lWzFdKGEsYixjLGQpO2JyZWFrfWlmKG51bGw9PWgpdGhyb3dcImNvbG9yIG1vZGUgXCIrZCtcIiBpcyBub3Qgc3VwcG9ydGVkXCI7cmV0dXJuIGguYWxwaGEoYS5hbHBoYSgpK2MqKGIuYWxwaGEoKS1hLmFscGhhKCkpKSxofSxzLmludGVycG9sYXRlPUgsYS5wcm90b3R5cGUuaW50ZXJwb2xhdGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBIKHRoaXMsYSxiLGMpfSxzLm1peD1ILGEucHJvdG90eXBlLm1peD1hLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSxMPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmLGc7cmV0dXJuIGY9Yi5fcmdiLGc9Yy5fcmdiLG5ldyBhKGZbMF0rZCooZ1swXS1mWzBdKSxmWzFdK2QqKGdbMV0tZlsxXSksZlsyXStkKihnWzJdLWZbMl0pLGUpfSxrLnB1c2goW1wicmdiXCIsTF0pLGEucHJvdG90eXBlLmx1bWluYW5jZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmO3JldHVybiBudWxsPT1iJiYoYj1cInJnYlwiKSxhcmd1bWVudHMubGVuZ3RoPygwPT09YT90aGlzLl9yZ2I9WzAsMCwwLHRoaXMuX3JnYlszXV06MT09PWE/dGhpcy5fcmdiPVsyNTUsMjU1LDI1NSx0aGlzLl9yZ2JbM11dOihkPTFlLTcsZT0yMCxmPWZ1bmN0aW9uKGMsZyl7dmFyIGgsaTtyZXR1cm4gaT1jLmludGVycG9sYXRlKGcsLjUsYiksaD1pLmx1bWluYW5jZSgpLE1hdGguYWJzKGEtaCk8ZHx8IWUtLT9pOmg+YT9mKGMsaSk6ZihpLGcpfSxjPWlhKHRoaXMuX3JnYiksdGhpcy5fcmdiPShjPmE/ZihzKFwiYmxhY2tcIiksdGhpcyk6Zih0aGlzLHMoXCJ3aGl0ZVwiKSkpLnJnYmEoKSksdGhpcyk6aWEodGhpcy5fcmdiKX0sdGE9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU7cmV0dXJuIGU9YS8xMDAsNjY+ZT8oZD0yNTUsYz0tMTU1LjI1NDg1NTYyNzA5MTc5LS40NDU5Njk1MDQ2OTU3OTEzMyooYz1lLTIpKzEwNC40OTIxNjE5OTM5Mzg4OCpUKGMpLGI9MjA+ZT8wOi0yNTQuNzY5MzUxODQxMjA5MDIrLjgyNzQwOTYwNjQwMDczOTUqKGI9ZS0xMCkrMTE1LjY3OTk0NDAxMDY2MTQ3KlQoYikpOihkPTM1MS45NzY5MDU2NjgwNTY5MysuMTE0MjA2NDUzNzg0MTY1KihkPWUtNTUpLTQwLjI1MzY2MzA5MzMyMTI3KlQoZCksYz0zMjUuNDQ5NDEyNTcxMTk3NCsuMDc5NDM0NTY1MzY2NjIzNDIqKGM9ZS01MCktMjguMDg1Mjk2MzUwNzk1NypUKGMpLGI9MjU1KSx0KFtkLGMsYl0pfSxrYT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkLGUsZixnLGgsaTtmb3IoZz12YShhcmd1bWVudHMpLGY9Z1swXSxjPWdbMV0sYT1nWzJdLGU9MWUzLGQ9NGU0LGI9LjQ7ZC1lPmI7KWk9LjUqKGQrZSksaD10YShpKSxoWzJdL2hbMF0+PWEvZj9kPWk6ZT1pO3JldHVybiBwYShpKX0scy50ZW1wZXJhdHVyZT1zLmtlbHZpbj1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhLGIsYyl7Yy5wcm90b3R5cGU9YS5wcm90b3R5cGU7dmFyIGQ9bmV3IGMsZT1hLmFwcGx5KGQsYik7cmV0dXJuIE9iamVjdChlKT09PWU/ZTpkfShhLHphLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoW1widGVtcGVyYXR1cmVcIl0pLGZ1bmN0aW9uKCl7fSl9LGoudGVtcGVyYXR1cmU9ai5rZWx2aW49ai5LPXRhLGEucHJvdG90eXBlLnRlbXBlcmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGthKHRoaXMuX3JnYil9LGEucHJvdG90eXBlLmtlbHZpbj1hLnByb3RvdHlwZS50ZW1wZXJhdHVyZSxzLmNvbnRyYXN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQsZSxmLGc7cmV0dXJuKFwic3RyaW5nXCI9PT0oZj11YShiKSl8fFwibnVtYmVyXCI9PT1mKSYmKGI9bmV3IGEoYikpLChcInN0cmluZ1wiPT09KGc9dWEoYykpfHxcIm51bWJlclwiPT09ZykmJihjPW5ldyBhKGMpKSxkPWIubHVtaW5hbmNlKCksZT1jLmx1bWluYW5jZSgpLGQ+ZT8oZCsuMDUpLyhlKy4wNSk6KGUrLjA1KS8oZCsuMDUpfSxhLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnO3JldHVybiBkPXRoaXMsZj1hLnNwbGl0KFwiLlwiKSxlPWZbMF0sYj1mWzFdLGc9ZFtlXSgpLGI/KGM9ZS5pbmRleE9mKGIpLGM+LTE/Z1tjXTpjb25zb2xlLndhcm4oXCJ1bmtub3duIGNoYW5uZWwgXCIrYitcIiBpbiBtb2RlIFwiK2UpKTpnfSxhLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg7aWYoZT10aGlzLGc9YS5zcGxpdChcIi5cIiksZj1nWzBdLGM9Z1sxXSxjKWlmKGg9ZVtmXSgpLGQ9Zi5pbmRleE9mKGMpLGQ+LTEpaWYoXCJzdHJpbmdcIj09PXVhKGIpKXN3aXRjaChiLmNoYXJBdCgwKSl7Y2FzZVwiK1wiOmhbZF0rPStiO2JyZWFrO2Nhc2VcIi1cIjpoW2RdKz0rYjticmVhaztjYXNlXCIqXCI6aFtkXSo9K2Iuc3Vic3RyKDEpO2JyZWFrO2Nhc2VcIi9cIjpoW2RdLz0rYi5zdWJzdHIoMSk7YnJlYWs7ZGVmYXVsdDpoW2RdPStifWVsc2UgaFtkXT1iO2Vsc2UgY29uc29sZS53YXJuKFwidW5rbm93biBjaGFubmVsIFwiK2MrXCIgaW4gbW9kZSBcIitmKTtlbHNlIGg9YjtyZXR1cm4gZS5fcmdiPXMoaCxmKS5hbHBoYShlLmFscGhhKCkpLl9yZ2IsZX0sYS5wcm90b3R5cGUuZGFya2VuPWZ1bmN0aW9uKGEpe3ZhciBiLGQ7cmV0dXJuIG51bGw9PWEmJihhPTEpLGQ9dGhpcyxiPWQubGFiKCksYlswXS09Yy5LbiphLHMubGFiKGIpLmFscGhhKGQuYWxwaGEoKSl9LGEucHJvdG90eXBlLmJyaWdodGVuPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiYoYT0xKSx0aGlzLmRhcmtlbigtYSl9LGEucHJvdG90eXBlLmRhcmtlcj1hLnByb3RvdHlwZS5kYXJrZW4sYS5wcm90b3R5cGUuYnJpZ2h0ZXI9YS5wcm90b3R5cGUuYnJpZ2h0ZW4sYS5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24oYSl7dmFyIGIsZDtyZXR1cm4gbnVsbD09YSYmKGE9MSksZD10aGlzLGI9ZC5sY2goKSxiWzFdKz1hKmMuS24sYlsxXTwwJiYoYlsxXT0wKSxzLmxjaChiKS5hbHBoYShkLmFscGhhKCkpfSxhLnByb3RvdHlwZS5kZXNhdHVyYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiYoYT0xKSx0aGlzLnNhdHVyYXRlKC1hKX0sYS5wcm90b3R5cGUucHJlbXVsdGlwbHk9ZnVuY3Rpb24oKXt2YXIgYSxiO3JldHVybiBiPXRoaXMucmdiKCksYT10aGlzLmFscGhhKCkscyhiWzBdKmEsYlsxXSphLGJbMl0qYSxhKX0sbz1mdW5jdGlvbihhLGIsYyl7aWYoIW9bY10pdGhyb3dcInVua25vd24gYmxlbmQgbW9kZSBcIitjO3JldHVybiBvW2NdKGEsYil9LHA9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQsZTtyZXR1cm4gZD1zKGMpLnJnYigpLGU9cyhiKS5yZ2IoKSxzKGEoZCxlKSxcInJnYlwiKX19LEE9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQsZSxmO2ZvcihmPVtdLGQ9ZT0wOzM+PWU7ZD0rK2UpZltkXT1hKGJbZF0sY1tkXSk7cmV0dXJuIGZ9fSxZPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGF9LFg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYSpiLzI1NX0seT1mdW5jdGlvbihhLGIpe3JldHVybiBhPmI/YjphfSxSPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGE+Yj9hOmJ9LHFhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDI1NSooMS0oMS1hLzI1NSkqKDEtYi8yNTUpKX0sJD1mdW5jdGlvbihhLGIpe3JldHVybiAxMjg+Yj8yKmEqYi8yNTU6MjU1KigxLTIqKDEtYS8yNTUpKigxLWIvMjU1KSl9LHI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMjU1KigxLSgxLWIvMjU1KS8oYS8yNTUpKX0sej1mdW5jdGlvbihhLGIpe3JldHVybiAyNTU9PT1hPzI1NTooYT0yNTUqKGIvMjU1KS8oMS1hLzI1NSksYT4yNTU/MjU1OmEpfSxvLm5vcm1hbD1wKEEoWSkpLG8ubXVsdGlwbHk9cChBKFgpKSxvLnNjcmVlbj1wKEEocWEpKSxvLm92ZXJsYXk9cChBKCQpKSxvLmRhcmtlbj1wKEEoeSkpLG8ubGlnaHRlbj1wKEEoUikpLG8uZG9kZ2U9cChBKHopKSxvLmJ1cm49cChBKHIpKSxzLmJsZW5kPW8scy5hbmFseXplPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlO2ZvcihkPXttaW46TnVtYmVyLk1BWF9WQUxVRSxtYXg6LTEqTnVtYmVyLk1BWF9WQUxVRSxzdW06MCx2YWx1ZXM6W10sY291bnQ6MH0sYz0wLGI9YS5sZW5ndGg7Yj5jO2MrKyllPWFbY10sbnVsbD09ZXx8aXNOYU4oZSl8fChkLnZhbHVlcy5wdXNoKGUpLGQuc3VtKz1lLGU8ZC5taW4mJihkLm1pbj1lKSxlPmQubWF4JiYoZC5tYXg9ZSksZC5jb3VudCs9MSk7cmV0dXJuIGQuZG9tYWluPVtkLm1pbixkLm1heF0sZC5saW1pdHM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gcy5saW1pdHMoZCxhLGIpfSxkfSxzLnNjYWxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIsdCx1LHYsdyx4O3JldHVybiBrPVwicmdiXCIsbD1zKFwiI2NjY1wiKSxwPTAsaD0hMSxnPVswLDFdLG89W10sbj1bMCwwXSxjPSExLGU9W10sbT0hMSxqPTAsaT0xLGY9ITEsZD17fSx3PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxmLGcsaCxpO2lmKG51bGw9PWEmJihhPVtcIiNmZmZcIixcIiMwMDBcIl0pLG51bGwhPWEmJlwic3RyaW5nXCI9PT11YShhKSYmbnVsbCE9KG51bGwhPShmPXMuYnJld2VyKT9mW2FdOnZvaWQgMCkmJihhPXMuYnJld2VyW2FdKSxcImFycmF5XCI9PT11YShhKSl7Zm9yKGE9YS5zbGljZSgwKSxiPWQ9MCxnPWEubGVuZ3RoLTE7Zz49MD9nPj1kOmQ+PWc7Yj1nPj0wPysrZDotLWQpYz1hW2JdLFwic3RyaW5nXCI9PT11YShjKSYmKGFbYl09cyhjKSk7Zm9yKG8ubGVuZ3RoPTAsYj1pPTAsaD1hLmxlbmd0aC0xO2g+PTA/aD49aTppPj1oO2I9aD49MD8rK2k6LS1pKW8ucHVzaChiLyhhLmxlbmd0aC0xKSl9cmV0dXJuIHYoKSxlPWF9LHQ9ZnVuY3Rpb24oYSl7dmFyIGIsZDtpZihudWxsIT1jKXtmb3IoZD1jLmxlbmd0aC0xLGI9MDtkPmImJmE+PWNbYl07KWIrKztyZXR1cm4gYi0xfXJldHVybiAwfSx4PWZ1bmN0aW9uKGEpe3JldHVybiBhfSxxPWZ1bmN0aW9uKGEpe3ZhciBiLGQsZSxmLGc7cmV0dXJuIGc9YSxjLmxlbmd0aD4yJiYoZj1jLmxlbmd0aC0xLGI9dChhKSxlPWNbMF0rKGNbMV0tY1swXSkqKDArLjUqcCksZD1jW2YtMV0rKGNbZl0tY1tmLTFdKSooMS0uNSpwKSxnPWorKGNbYl0rLjUqKGNbYisxXS1jW2JdKS1lKS8oZC1lKSooaS1qKSksZ30sdT1mdW5jdGlvbihhLGIpe3ZhciBmLGcsaCxtLHAscSxyLHU7aWYobnVsbD09YiYmKGI9ITEpLGlzTmFOKGEpKXJldHVybiBsO2lmKGI/dT1hOmMmJmMubGVuZ3RoPjI/KGY9dChhKSx1PWYvKGMubGVuZ3RoLTIpLHU9blswXSt1KigxLW5bMF0tblsxXSkpOmkhPT1qPyh1PShhLWopLyhpLWopLHU9blswXSt1KigxLW5bMF0tblsxXSksdT1NYXRoLm1pbigxLE1hdGgubWF4KDAsdSkpKTp1PTEsYnx8KHU9eCh1KSksbT1NYXRoLmZsb29yKDFlNCp1KSxkW21dKWc9ZFttXTtlbHNle2lmKFwiYXJyYXlcIj09PXVhKGUpKWZvcihoPXA9MCxyPW8ubGVuZ3RoLTE7cj49MD9yPj1wOnA+PXI7aD1yPj0wPysrcDotLXApe2lmKHE9b1toXSxxPj11KXtnPWVbaF07YnJlYWt9aWYodT49cSYmaD09PW8ubGVuZ3RoLTEpe2c9ZVtoXTticmVha31pZih1PnEmJnU8b1toKzFdKXt1PSh1LXEpLyhvW2grMV0tcSksZz1zLmludGVycG9sYXRlKGVbaF0sZVtoKzFdLHUsayk7YnJlYWt9fWVsc2VcImZ1bmN0aW9uXCI9PT11YShlKSYmKGc9ZSh1KSk7ZFttXT1nfXJldHVybiBnfSx2PWZ1bmN0aW9uKCl7cmV0dXJuIGQ9e319LHcoYSkscj1mdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gYj1zKHUoYSkpLG0mJmJbbV0/YlttXSgpOmJ9LHIuY2xhc3Nlcz1mdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gbnVsbCE9YT8oXCJhcnJheVwiPT09dWEoYSk/KGM9YSxnPVthWzBdLGFbYS5sZW5ndGgtMV1dKTooYj1zLmFuYWx5emUoZyksYz0wPT09YT9bYi5taW4sYi5tYXhdOnMubGltaXRzKGIsXCJlXCIsYSkpLHIpOmN9LHIuZG9tYWluPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxmLGgsayxsO2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiBnO2lmKGo9YVswXSxpPWFbYS5sZW5ndGgtMV0sbz1bXSxkPWUubGVuZ3RoLGEubGVuZ3RoPT09ZCYmaiE9PWkpZm9yKGg9MCxmPWEubGVuZ3RoO2Y+aDtoKyspYz1hW2hdLG8ucHVzaCgoYy1qKS8oaS1qKSk7ZWxzZSBmb3IoYj1sPTAsaz1kLTE7az49MD9rPj1sOmw+PWs7Yj1rPj0wPysrbDotLWwpby5wdXNoKGIvKGQtMSkpO3JldHVybiBnPVtqLGldLHJ9LHIubW9kZT1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaz1hLHYoKSxyKTprfSxyLnJhbmdlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHcoYSxiKSxyfSxyLm91dD1mdW5jdGlvbihhKXtyZXR1cm4gbT1hLHJ9LHIuc3ByZWFkPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhwPWEscik6cH0sci5jb3JyZWN0TGlnaHRuZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiYoYT0hMCksZj1hLHYoKSx4PWY/ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaSxqO2ZvcihiPXUoMCwhMCkubGFiKClbMF0sYz11KDEsITApLmxhYigpWzBdLGg9Yj5jLGQ9dShhLCEwKS5sYWIoKVswXSxmPWIrKGMtYikqYSxlPWQtZixpPTAsaj0xLGc9MjA7TWF0aC5hYnMoZSk+LjAxJiZnLS0+MDspIWZ1bmN0aW9uKCl7cmV0dXJuIGgmJihlKj0tMSksMD5lPyhpPWEsYSs9LjUqKGotYSkpOihqPWEsYSs9LjUqKGktYSkpLGQ9dShhLCEwKS5sYWIoKVswXSxlPWQtZn0oKTtyZXR1cm4gYX06ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHJ9LHIucGFkZGluZz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT8oXCJudW1iZXJcIj09PXVhKGEpJiYoYT1bYSxhXSksbj1hLHIpOm59LHIuY29sb3JzPWZ1bmN0aW9uKCl7dmFyIGIsZCxlLGYsaCxpLGosayxsO2lmKGY9MCxoPVwiaGV4XCIsMT09PWFyZ3VtZW50cy5sZW5ndGgmJihcInN0cmluZ1wiPT09dWEoYXJndW1lbnRzWzBdKT9oPWFyZ3VtZW50c1swXTpmPWFyZ3VtZW50c1swXSksMj09PWFyZ3VtZW50cy5sZW5ndGgmJihmPWFyZ3VtZW50c1swXSxoPWFyZ3VtZW50c1sxXSksZilyZXR1cm4gZD1nWzBdLGI9Z1sxXS1kLGZ1bmN0aW9uKCl7aj1bXTtmb3IodmFyIGE9MDtmPj0wP2Y+YTphPmY7Zj49MD9hKys6YS0tKWoucHVzaChhKTtyZXR1cm4gan0uYXBwbHkodGhpcykubWFwKGZ1bmN0aW9uKGEpe3JldHVybiByKGQrYS8oZi0xKSpiKVtoXSgpfSk7aWYoYT1bXSxrPVtdLGMmJmMubGVuZ3RoPjIpZm9yKGU9bD0xLGk9Yy5sZW5ndGg7aT49MT9pPmw6bD5pO2U9aT49MT8rK2w6LS1sKWsucHVzaCguNSooY1tlLTFdK2NbZV0pKTtlbHNlIGs9ZztyZXR1cm4gay5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHIoYSlbaF0oKX0pfSxyfSxudWxsPT1zLnNjYWxlcyYmKHMuc2NhbGVzPXt9KSxzLnNjYWxlcy5jb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHMuc2NhbGUoW3MuaHNsKDE4MCwxLC45KSxzLmhzbCgyNTAsLjcsLjQpXSl9LHMuc2NhbGVzLmhvdD1mdW5jdGlvbigpe3JldHVybiBzLnNjYWxlKFtcIiMwMDBcIixcIiNmMDBcIixcIiNmZjBcIixcIiNmZmZcIl0sWzAsLjI1LC43NSwxXSkubW9kZShcInJnYlwiKX0scy5hbmFseXplPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoLGksajtpZihoPXttaW46TnVtYmVyLk1BWF9WQUxVRSxtYXg6LTEqTnVtYmVyLk1BWF9WQUxVRSxzdW06MCx2YWx1ZXM6W10sY291bnQ6MH0sbnVsbD09YyYmKGM9ZnVuY3Rpb24oKXtyZXR1cm4hMH0pLGQ9ZnVuY3Rpb24oYSl7bnVsbD09YXx8aXNOYU4oYSl8fChoLnZhbHVlcy5wdXNoKGEpLGguc3VtKz1hLGE8aC5taW4mJihoLm1pbj1hKSxhPmgubWF4JiYoaC5tYXg9YSksaC5jb3VudCs9MSl9LGo9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gYyhhLGUpP2QobnVsbCE9YiYmXCJmdW5jdGlvblwiPT09dWEoYik/YihhKTpudWxsIT1iJiZcInN0cmluZ1wiPT09dWEoYil8fFwibnVtYmVyXCI9PT11YShiKT9hW2JdOmEpOnZvaWQgMH0sXCJhcnJheVwiPT09dWEoYSkpZm9yKGc9MCxmPWEubGVuZ3RoO2Y+ZztnKyspaT1hW2ddLGooaSk7ZWxzZSBmb3IoZSBpbiBhKWk9YVtlXSxqKGksZSk7cmV0dXJuIGguZG9tYWluPVtoLm1pbixoLm1heF0saC5saW1pdHM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gcy5saW1pdHMoaCxhLGIpfSxofSxzLmxpbWl0cz1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaCxpLGosayxtLG4sbyxwLHEscix0LHUsdix3LHgseSx6LEEsQyxELEUsRixHLEgsSSxKLEssTCxNLE4sTyxQLFEsUixTLFUsVixYLFksWiwkLGFhLGJhLGNhLGRhLGVhLGZhLGdhLGhhLGlhLGphO2lmKG51bGw9PWImJihiPVwiZXF1YWxcIiksbnVsbD09YyYmKGM9NyksXCJhcnJheVwiPT09dWEoYSkmJihhPXMuYW5hbHl6ZShhKSksRT1hLm1pbixXPWEubWF4LGZhPWEuc3VtLGlhPWEudmFsdWVzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSksQz1bXSxcImNcIj09PWIuc3Vic3RyKDAsMSkmJihDLnB1c2goRSksQy5wdXNoKFcpKSxcImVcIj09PWIuc3Vic3RyKDAsMSkpe2ZvcihDLnB1c2goRSkseT1LPTEsTz1jLTE7Tz49MT9PPj1LOks+PU87eT1PPj0xPysrSzotLUspQy5wdXNoKEUreS9jKihXLUUpKTtDLnB1c2goVyl9ZWxzZSBpZihcImxcIj09PWIuc3Vic3RyKDAsMSkpe2lmKDA+PUUpdGhyb3dcIkxvZ2FyaXRobWljIHNjYWxlcyBhcmUgb25seSBwb3NzaWJsZSBmb3IgdmFsdWVzID4gMFwiO2ZvcihGPU1hdGguTE9HMTBFKlQoRSksRD1NYXRoLkxPRzEwRSpUKFcpLEMucHVzaChFKSx5PWphPTEsUD1jLTE7UD49MT9QPj1qYTpqYT49UDt5PVA+PTE/KytqYTotLWphKUMucHVzaChfKDEwLEYreS9jKihELUYpKSk7Qy5wdXNoKFcpfWVsc2UgaWYoXCJxXCI9PT1iLnN1YnN0cigwLDEpKXtmb3IoQy5wdXNoKEUpLHk9ZD0xLFg9Yy0xO1g+PTE/WD49ZDpkPj1YO3k9WD49MT8rK2Q6LS1kKUw9aWEubGVuZ3RoKnkvYyxNPUIoTCksTT09PUw/Qy5wdXNoKGlhW01dKTooTj1MLU0sQy5wdXNoKGlhW01dKk4raWFbTSsxXSooMS1OKSkpO0MucHVzaChXKX1lbHNlIGlmKFwia1wiPT09Yi5zdWJzdHIoMCwxKSl7Zm9yKEg9aWEubGVuZ3RoLHI9bmV3IEFycmF5KEgpLHc9bmV3IEFycmF5KGMpLGVhPSEwLEk9MCx1PW51bGwsdT1bXSx1LnB1c2goRSkseT1lPTEsWT1jLTE7WT49MT9ZPj1lOmU+PVk7eT1ZPj0xPysrZTotLWUpdS5wdXNoKEUreS9jKihXLUUpKTtmb3IodS5wdXNoKFcpO2VhOyl7Zm9yKHo9Zj0wLFo9Yy0xO1o+PTA/Wj49ZjpmPj1aO3o9Wj49MD8rK2Y6LS1mKXdbel09MDtmb3IoeT1nPTAsJD1ILTE7JD49MD8kPj1nOmc+PSQ7eT0kPj0wPysrZzotLWcpe2ZvcihoYT1pYVt5XSxHPU51bWJlci5NQVhfVkFMVUUsej1oPTAsYWE9Yy0xO2FhPj0wP2FhPj1oOmg+PWFhO3o9YWE+PTA/KytoOi0taCl4PWwodVt6XS1oYSksRz54JiYoRz14LHQ9eik7d1t0XSsrLHJbeV09dH1mb3IoSj1uZXcgQXJyYXkoYyksej1pPTAsYmE9Yy0xO2JhPj0wP2JhPj1pOmk+PWJhO3o9YmE+PTA/KytpOi0taSlKW3pdPW51bGw7Zm9yKHk9aj0wLGNhPUgtMTtjYT49MD9jYT49ajpqPj1jYTt5PWNhPj0wPysrajotLWopdj1yW3ldLG51bGw9PT1KW3ZdP0pbdl09aWFbeV06Slt2XSs9aWFbeV07Zm9yKHo9az0wLGRhPWMtMTtkYT49MD9kYT49azprPj1kYTt6PWRhPj0wPysrazotLWspSlt6XSo9MS93W3pdO2ZvcihlYT0hMSx6PW09MCxRPWMtMTtRPj0wP1E+PW06bT49UTt6PVE+PTA/KyttOi0tbSlpZihKW3pdIT09dVt5XSl7ZWE9ITA7YnJlYWt9dT1KLEkrKyxJPjIwMCYmKGVhPSExKX1mb3IoQT17fSx6PW49MCxSPWMtMTtSPj0wP1I+PW46bj49Ujt6PVI+PTA/KytuOi0tbilBW3pdPVtdO2Zvcih5PW89MCxTPUgtMTtTPj0wP1M+PW86bz49Uzt5PVM+PTA/KytvOi0tbyl2PXJbeV0sQVt2XS5wdXNoKGlhW3ldKTtmb3IoZ2E9W10sej1wPTAsVT1jLTE7VT49MD9VPj1wOnA+PVU7ej1VPj0wPysrcDotLXApZ2EucHVzaChBW3pdWzBdKSxnYS5wdXNoKEFbel1bQVt6XS5sZW5ndGgtMV0pO2ZvcihnYT1nYS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pLEMucHVzaChnYVswXSkseT1xPTEsVj1nYS5sZW5ndGgtMTtWPj1xO3k9cSs9Milpc05hTihnYVt5XSl8fEMucHVzaChnYVt5XSl9cmV0dXJuIEN9LEQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGYsaCxpO3JldHVybiBkPXZhKGFyZ3VtZW50cyksYT1kWzBdLGI9ZFsxXSxjPWRbMl0sYS89MzYwLDEvMz5hPyhmPSgxLWIpLzMsaT0oMStiKncoZyphKS93KGUtZyphKSkvMyxoPTEtKGYraSkpOjIvMz5hPyhhLT0xLzMsaT0oMS1iKS8zLGg9KDErYip3KGcqYSkvdyhlLWcqYSkpLzMsZj0xLShpK2gpKTooYS09Mi8zLGg9KDEtYikvMyxmPSgxK2IqdyhnKmEpL3coZS1nKmEpKS8zLGk9MS0oaCtmKSksaT1TKGMqaSozKSxoPVMoYypoKjMpLGY9UyhjKmYqMyksWzI1NSppLDI1NSpoLDI1NSpmLGQubGVuZ3RoPjM/ZFszXToxXX0sZGE9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsaCxpO3JldHVybiBoPXZhKGFyZ3VtZW50cyksZj1oWzBdLGI9aFsxXSxhPWhbMl0sZz0yKk1hdGguUEksZi89MjU1LGIvPTI1NSxhLz0yNTUsZT1NYXRoLm1pbihmLGIsYSksZD0oZitiK2EpLzMsaT0xLWUvZCwwPT09aT9jPTA6KGM9KGYtYisoZi1hKSkvMixjLz1NYXRoLnNxcnQoKGYtYikqKGYtYikrKGYtYSkqKGItYSkpLGM9TWF0aC5hY29zKGMpLGE+YiYmKGM9Zy1jKSxjLz1nKSxbMzYwKmMsaSxkXX0scy5oc2k9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2MucHJvdG90eXBlPWEucHJvdG90eXBlO3ZhciBkPW5ldyBjLGU9YS5hcHBseShkLGIpO3JldHVybiBPYmplY3QoZSk9PT1lP2U6ZH0oYSx6YS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KFtcImhzaVwiXSksZnVuY3Rpb24oKXt9KX0sai5oc2k9RCxhLnByb3RvdHlwZS5oc2k9ZnVuY3Rpb24oKXtyZXR1cm4gZGEodGhpcy5fcmdiKX0sST1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGcsaCxpLGosayxsLG0sbixvLHAscTtyZXR1cm5cImhzbFwiPT09ZD8ocD1hLmhzbCgpLHE9Yi5oc2woKSk6XCJoc3ZcIj09PWQ/KHA9YS5oc3YoKSxxPWIuaHN2KCkpOlwiaHNpXCI9PT1kPyhwPWEuaHNpKCkscT1iLmhzaSgpKTooXCJsY2hcIj09PWR8fFwiaGNsXCI9PT1kKSYmKGQ9XCJoY2xcIixwPWEuaGNsKCkscT1iLmhjbCgpKSxcImhcIj09PWQuc3Vic3RyKDAsMSkmJihnPXBbMF0sbj1wWzFdLGo9cFsyXSxoPXFbMF0sbz1xWzFdLGs9cVsyXSksaXNOYU4oZyl8fGlzTmFOKGgpP2lzTmFOKGcpP2lzTmFOKGgpP2Y9TnVtYmVyLk5hTjooZj1oLDEhPT1qJiYwIT09anx8XCJoc3ZcIj09PWR8fChtPW8pKTooZj1nLDEhPT1rJiYwIT09a3x8XCJoc3ZcIj09PWR8fChtPW4pKTooZT1oPmcmJmgtZz4xODA/aC0oZyszNjApOmc+aCYmZy1oPjE4MD9oKzM2MC1nOmgtZyxmPWcrYyplKSxudWxsPT1tJiYobT1uK2MqKG8tbikpLGk9aitjKihrLWopLGw9c1tkXShmLG0saSl9LGs9ay5jb25jYXQoZnVuY3Rpb24oKXt2YXIgYSxiLGMsZDtmb3IoYz1bXCJoc3ZcIixcImhzbFwiLFwiaHNpXCIsXCJoY2xcIixcImxjaFwiXSxkPVtdLGI9MCxhPWMubGVuZ3RoO2E+YjtiKyspVj1jW2JdLGQucHVzaChbVixJXSk7cmV0dXJuIGR9KCkpLEs9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZjtyZXR1cm4gZT1hLm51bSgpLGY9Yi5udW0oKSxzLm51bShlKyhmLWUpKmMsXCJudW1cIil9LGsucHVzaChbXCJudW1cIixLXSksSj1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZixnLGg7cmV0dXJuIGc9Yi5sYWIoKSxoPWMubGFiKCksZj1uZXcgYShnWzBdK2QqKGhbMF0tZ1swXSksZ1sxXStkKihoWzFdLWdbMV0pLGdbMl0rZCooaFsyXS1nWzJdKSxlKTtcclxufSxrLnB1c2goW1wibGFiXCIsSl0pfSkuY2FsbCh0aGlzKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi9jaHJvbWEubWluLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./src/lib/earcut.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === signedArea(data, start, end, dim) > 0) {\n        for (i = start; i < end; i += dim) {\n            last = insertNode(i, data[i], data[i + 1], last);\n        }\n    } else {\n        for (i = end - dim; i >= start; i -= dim) {\n            last = insertNode(i, data[i], data[i + 1], last);\n        }\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev,\n        next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, size);\n                earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i,\n        len,\n        start,\n        end,\n        list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i,\n        p,\n        q,\n        e,\n        tail,\n        numMerges,\n        pSize,\n        qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n\n            qSize = inSize;\n\n            while (pSize > 0 || qSize > 0 && q) {\n\n                if (pSize === 0) {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                } else if (qSize === 0 || !q) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else if (p.z <= q.z) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n\n    return x | y << 1;\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = { vertices: [], holes: [], dimensions: dim },\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) {\n                result.vertices.push(data[i][j][d]);\n            }\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL2VhcmN1dC5qcz9jNzMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xyXG5cclxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcclxuXHJcbiAgICBkaW0gPSBkaW0gfHwgMjtcclxuXHJcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXHJcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcclxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoIW91dGVyTm9kZSkgcmV0dXJuIHRyaWFuZ2xlcztcclxuXHJcbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZTtcclxuXHJcbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XHJcblxyXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xyXG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcclxuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcclxuICAgICAgICAgICAgeCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcclxuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcclxuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcclxuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICB9XHJcblxyXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG5cclxuICAgIHJldHVybiB0cmlhbmdsZXM7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XHJcbiAgICB2YXIgaSwgbGFzdDtcclxuXHJcbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XHJcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcclxuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXN0O1xyXG59XHJcblxyXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xyXG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xyXG5cclxuICAgIHZhciBwID0gc3RhcnQsXHJcbiAgICAgICAgYWdhaW47XHJcbiAgICBkbyB7XHJcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xyXG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XHJcblxyXG4gICAgcmV0dXJuIGVuZDtcclxufVxyXG5cclxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXHJcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCBwYXNzKSB7XHJcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xyXG5cclxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XHJcblxyXG4gICAgdmFyIHN0b3AgPSBlYXIsXHJcbiAgICAgICAgcHJldiwgbmV4dDtcclxuXHJcbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcclxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcclxuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XHJcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xyXG5cclxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XHJcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcclxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcclxuXHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcclxuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWFyID0gbmV4dDtcclxuXHJcbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcclxuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XHJcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXHJcbiAgICAgICAgICAgIGlmICghcGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XHJcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XHJcblxyXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xyXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcclxuICAgIHZhciBhID0gZWFyLnByZXYsXHJcbiAgICAgICAgYiA9IGVhcixcclxuICAgICAgICBjID0gZWFyLm5leHQ7XHJcblxyXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXHJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XHJcblxyXG4gICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XHJcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkge1xyXG4gICAgdmFyIGEgPSBlYXIucHJldixcclxuICAgICAgICBiID0gZWFyLFxyXG4gICAgICAgIGMgPSBlYXIubmV4dDtcclxuXHJcbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXHJcblxyXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcclxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXHJcbiAgICAgICAgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLFxyXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcclxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XHJcblxyXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXHJcbiAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xyXG5cclxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxyXG4gICAgdmFyIHAgPSBlYXIubmV4dFo7XHJcblxyXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcclxuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxyXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcCA9IHAubmV4dFo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXHJcbiAgICBwID0gZWFyLnByZXZaO1xyXG5cclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XHJcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHAgPSBwLnByZXZaO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xyXG4gICAgdmFyIHAgPSBzdGFydDtcclxuICAgIGRvIHtcclxuICAgICAgICB2YXIgYSA9IHAucHJldixcclxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xyXG5cclxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XHJcblxyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XHJcblxyXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xyXG5cclxuICAgIHJldHVybiBwO1xyXG59XHJcblxyXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxyXG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpIHtcclxuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXHJcbiAgICB2YXIgYSA9IHN0YXJ0O1xyXG4gICAgZG8ge1xyXG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xyXG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xyXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXHJcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gYi5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBhID0gYS5uZXh0O1xyXG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xyXG59XHJcblxyXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXHJcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xyXG4gICAgdmFyIHF1ZXVlID0gW10sXHJcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcclxuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XHJcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XHJcblxyXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcclxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XHJcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRlck5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcclxuICAgIHJldHVybiBhLnggLSBiLng7XHJcbn1cclxuXHJcbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxyXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcclxuICAgIGlmIChvdXRlck5vZGUpIHtcclxuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xyXG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXHJcbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXHJcbiAgICAgICAgaHggPSBob2xlLngsXHJcbiAgICAgICAgaHkgPSBob2xlLnksXHJcbiAgICAgICAgcXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgbTtcclxuXHJcbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XHJcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcclxuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XHJcbiAgICAgICAgICAgICAgICBxeCA9IHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XHJcblxyXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBpZiAoaHggPT09IHF4KSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxyXG5cclxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcclxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xyXG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcclxuXHJcbiAgICB2YXIgc3RvcCA9IG0sXHJcbiAgICAgICAgbXggPSBtLngsXHJcbiAgICAgICAgbXkgPSBtLnksXHJcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXHJcbiAgICAgICAgdGFuO1xyXG5cclxuICAgIHAgPSBtLm5leHQ7XHJcblxyXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcclxuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJlxyXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xyXG5cclxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxyXG5cclxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBwO1xyXG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtO1xyXG59XHJcblxyXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXHJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIHNpemUpIHtcclxuICAgIHZhciBwID0gc3RhcnQ7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xyXG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcclxuXHJcbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcclxuICAgIHAucHJldlogPSBudWxsO1xyXG5cclxuICAgIHNvcnRMaW5rZWQocCk7XHJcbn1cclxuXHJcbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXHJcbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXHJcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xyXG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxyXG4gICAgICAgIGluU2l6ZSA9IDE7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHAgPSBsaXN0O1xyXG4gICAgICAgIGxpc3QgPSBudWxsO1xyXG4gICAgICAgIHRhaWwgPSBudWxsO1xyXG4gICAgICAgIG51bU1lcmdlcyA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChwKSB7XHJcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xyXG4gICAgICAgICAgICBxID0gcDtcclxuICAgICAgICAgICAgcFNpemUgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBTaXplKys7XHJcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcclxuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcclxuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwLnogPD0gcS56KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xyXG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XHJcbiAgICAgICAgaW5TaXplICo9IDI7XHJcblxyXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XHJcblxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XHJcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XHJcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXHJcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcclxuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgLyBzaXplO1xyXG5cclxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XHJcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xyXG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcclxuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XHJcblxyXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcclxuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XHJcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xyXG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcclxuXHJcbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xyXG59XHJcblxyXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXHJcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XHJcbiAgICB2YXIgcCA9IHN0YXJ0LFxyXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xyXG5cclxuICAgIHJldHVybiBsZWZ0bW9zdDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxyXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XHJcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcclxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxyXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcclxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcclxuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXHJcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKTtcclxufVxyXG5cclxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxyXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcclxuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcclxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xyXG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XHJcbiAgICBpZiAoKGVxdWFscyhwMSwgcTEpICYmIGVxdWFscyhwMiwgcTIpKSB8fFxyXG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGFyZWEocDEsIHExLCBwMikgPiAwICE9PSBhcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxyXG4gICAgICAgICAgIGFyZWEocDIsIHEyLCBwMSkgPiAwICE9PSBhcmVhKHAyLCBxMiwgcTEpID4gMDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcclxuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xyXG4gICAgdmFyIHAgPSBhO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXHJcbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XHJcbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxyXG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXHJcbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XHJcbiAgICB2YXIgcCA9IGEsXHJcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXHJcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXHJcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXHJcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xyXG5cclxuICAgIHJldHVybiBpbnNpZGU7XHJcbn1cclxuXHJcbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcclxuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXHJcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XHJcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcclxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxyXG4gICAgICAgIGFuID0gYS5uZXh0LFxyXG4gICAgICAgIGJwID0gYi5wcmV2O1xyXG5cclxuICAgIGEubmV4dCA9IGI7XHJcbiAgICBiLnByZXYgPSBhO1xyXG5cclxuICAgIGEyLm5leHQgPSBhbjtcclxuICAgIGFuLnByZXYgPSBhMjtcclxuXHJcbiAgICBiMi5uZXh0ID0gYTI7XHJcbiAgICBhMi5wcmV2ID0gYjI7XHJcblxyXG4gICAgYnAubmV4dCA9IGIyO1xyXG4gICAgYjIucHJldiA9IGJwO1xyXG5cclxuICAgIHJldHVybiBiMjtcclxufVxyXG5cclxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcclxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XHJcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xyXG5cclxuICAgIGlmICghbGFzdCkge1xyXG4gICAgICAgIHAucHJldiA9IHA7XHJcbiAgICAgICAgcC5uZXh0ID0gcDtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcclxuICAgICAgICBwLnByZXYgPSBsYXN0O1xyXG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcclxuICAgICAgICBsYXN0Lm5leHQgPSBwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xyXG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XHJcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcclxuXHJcbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XHJcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xyXG4gICAgLy8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxyXG4gICAgdGhpcy5pID0gaTtcclxuXHJcbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRpY2Ugbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcclxuICAgIHRoaXMucHJldiA9IG51bGw7XHJcbiAgICB0aGlzLm5leHQgPSBudWxsO1xyXG5cclxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcclxuICAgIHRoaXMueiA9IG51bGw7XHJcblxyXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XHJcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcclxuXHJcbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxyXG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XHJcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cclxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcclxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcclxuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcclxuXHJcbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcclxuICAgIGlmIChoYXNIb2xlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcclxuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XHJcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xyXG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXHJcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxyXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxyXG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcclxuICAgIHZhciBzdW0gPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xyXG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xyXG4gICAgICAgIGogPSBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bTtcclxufVxyXG5cclxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXHJcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcclxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXHJcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saWIvZWFyY3V0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/lib/rtree.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PolygonLookup = PolygonLookup;\n/**\r\n * Exports a `PolygonLookup` constructor, which constructs a data-structure for\r\n * quickly finding the polygon that a point intersects in a (potentially very\r\n * large) set.\r\n */\n\nvar pointInPolygon = function pointInPolygon(point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    var x = point[0],\n        y = point[1];\n\n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0],\n            yi = vs[i][1];\n        var xj = vs[j][0],\n            yj = vs[j][1];\n\n        var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) inside = !inside;\n    }\n\n    return inside;\n};\n\n/**\r\n * @property {rbush} rtree A spatial index for `this.polygons`.\r\n * @property {object} polgons A GeoJSON feature collection.\r\n *\r\n * @param {object} [featureCollection] An optional GeoJSON feature collection\r\n *    to pass to `loadFeatureCollection()`.\r\n */\nfunction PolygonLookup(featureCollection) {\n    this.search = function search(x, y) {\n        var bboxes = this.rtree.search([x, y, x, y]);\n        var pt = [x, y];\n        for (var ind = 0; ind < bboxes.length; ind++) {\n            var polyObj = this.polygons[bboxes[ind].polyId];\n            var polyCoords = polyObj.geometry.coordinates[0];\n            if (pointInPolygon(pt, polyCoords)) {\n                var inHole = false;\n                for (var subPolyInd = 1; subPolyInd < polyObj.geometry.coordinates.length; subPolyInd++) {\n                    if (pointInPolygon(pt, polyObj.geometry.coordinates[subPolyInd])) {\n                        inHole = true;\n                        break;\n                    }\n                }\n\n                if (!inHole) {\n                    return polyObj;\n                }\n            }\n        }\n    };\n\n    this.loadFeatureCollection = function loadFeatureCollection(collection) {\n        var bboxes = [];\n        var polygons = [];\n        var polyId = 0;\n\n        function getBoundingBox(poly) {\n            var firstPt = poly[0];\n            var bbox = [firstPt[0], firstPt[1], firstPt[0], firstPt[1]];\n\n            for (var ind = 1; ind < poly.length; ind++) {\n                var pt = poly[ind];\n\n                var x = pt[0];\n                if (x < bbox[0]) {\n                    bbox[0] = x;\n                } else if (x > bbox[2]) {\n                    bbox[2] = x;\n                }\n\n                var y = pt[1];\n                if (y < bbox[1]) {\n                    bbox[1] = y;\n                } else if (y > bbox[3]) {\n                    bbox[3] = y;\n                }\n            }\n\n            return bbox;\n        }\n\n        function indexPolygon(poly) {\n            polygons.push(poly);\n            var bbox = getBoundingBox(poly.geometry.coordinates[0]);\n            bbox.polyId = polyId++;\n            bboxes.push(bbox);\n        }\n\n        function indexFeature(poly) {\n            if (poly.geometry.coordinates[0] !== undefined && poly.geometry.coordinates[0].length > 0) {\n                switch (poly.geometry.type) {\n                    case 'Polygon':\n                        indexPolygon(poly);\n                        break;\n\n                    case 'MultiPolygon':\n                        var childPolys = poly.geometry.coordinates;\n                        for (var ind = 0; ind < childPolys.length; ind++) {\n                            var childPoly = {\n                                type: 'Feature',\n                                properties: poly.properties,\n                                geometry: {\n                                    type: 'Polygon',\n                                    coordinates: childPolys[ind]\n                                }\n                            };\n                            indexPolygon(childPoly);\n                        }\n                        break;\n                }\n            }\n        }\n\n        var rBush = function rbush() {\n\n            this.RBush = function (maxEntries, format) {\n\n                // jshint newcap: false, validthis: true\n                if (!(this instanceof RBush)) return new RBush(maxEntries, format);\n\n                // max entries in a node is 9 by default; min node fill is 40% for best performance\n                this._maxEntries = Math.max(4, maxEntries || 9);\n                this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n                if (format) {\n                    this._initFormat(format);\n                }\n\n                this.clear();\n            };\n\n            RBush.prototype = {\n\n                all: function all() {\n                    return this._all(this.data, []);\n                },\n\n                search: function search(bbox) {\n\n                    var node = this.data,\n                        result = [],\n                        toBBox = this.toBBox;\n\n                    if (!intersects(bbox, node.bbox)) return result;\n\n                    var nodesToSearch = [],\n                        i,\n                        len,\n                        child,\n                        childBBox;\n\n                    while (node) {\n                        for (i = 0, len = node.children.length; i < len; i++) {\n\n                            child = node.children[i];\n                            childBBox = node.leaf ? toBBox(child) : child.bbox;\n\n                            if (intersects(bbox, childBBox)) {\n                                if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                            }\n                        }\n                        node = nodesToSearch.pop();\n                    }\n\n                    return result;\n                },\n\n                load: function load(data) {\n                    if (!(data && data.length)) return this;\n\n                    if (data.length < this._minEntries) {\n                        for (var i = 0, len = data.length; i < len; i++) {\n                            this.insert(data[i]);\n                        }\n                        return this;\n                    }\n\n                    // recursively build the tree with the given data from stratch using OMT algorithm\n                    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n                    if (!this.data.children.length) {\n                        // save as is if tree is empty\n                        this.data = node;\n                    } else if (this.data.height === node.height) {\n                        // split root if trees have the same height\n                        this._splitRoot(this.data, node);\n                    } else {\n                        if (this.data.height < node.height) {\n                            // swap trees if inserted one is bigger\n                            var tmpNode = this.data;\n                            this.data = node;\n                            node = tmpNode;\n                        }\n\n                        // insert the small tree into the large tree at appropriate level\n                        this._insert(node, this.data.height - node.height - 1, true);\n                    }\n\n                    return this;\n                },\n\n                insert: function insert(item) {\n                    if (item) this._insert(item, this.data.height - 1);\n                    return this;\n                },\n\n                clear: function clear() {\n                    this.data = {\n                        children: [],\n                        height: 1,\n                        bbox: empty(),\n                        leaf: true\n                    };\n                    return this;\n                },\n\n                remove: function remove(item) {\n                    if (!item) return this;\n\n                    var node = this.data,\n                        bbox = this.toBBox(item),\n                        path = [],\n                        indexes = [],\n                        i,\n                        parent,\n                        index,\n                        goingUp;\n\n                    // depth-first iterative tree traversal\n                    while (node || path.length) {\n\n                        if (!node) {\n                            // go up\n                            node = path.pop();\n                            parent = path[path.length - 1];\n                            i = indexes.pop();\n                            goingUp = true;\n                        }\n\n                        if (node.leaf) {\n                            // check current node\n                            index = node.children.indexOf(item);\n\n                            if (index !== -1) {\n                                // item found, remove the item and condense tree upwards\n                                node.children.splice(index, 1);\n                                path.push(node);\n                                this._condense(path);\n                                return this;\n                            }\n                        }\n\n                        if (!goingUp && !node.leaf && contains(node.bbox, bbox)) {\n                            // go down\n                            path.push(node);\n                            indexes.push(i);\n                            i = 0;\n                            parent = node;\n                            node = node.children[0];\n                        } else if (parent) {\n                            // go right\n                            i++;\n                            node = parent.children[i];\n                            goingUp = false;\n                        } else node = null; // nothing found\n                    }\n\n                    return this;\n                },\n\n                toBBox: function toBBox(item) {\n                    return item;\n                },\n\n                compareMinX: function compareMinX(a, b) {\n                    return a[0] - b[0];\n                },\n                compareMinY: function compareMinY(a, b) {\n                    return a[1] - b[1];\n                },\n\n                toJSON: function toJSON() {\n                    return this.data;\n                },\n\n                fromJSON: function fromJSON(data) {\n                    this.data = data;\n                    return this;\n                },\n\n                _all: function _all(node, result) {\n                    var nodesToSearch = [];\n                    while (node) {\n                        if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n                        node = nodesToSearch.pop();\n                    }\n                    return result;\n                },\n\n                _build: function _build(items, left, right, height) {\n\n                    var N = right - left + 1,\n                        M = this._maxEntries,\n                        node;\n\n                    if (N <= M) {\n                        // reached leaf level; return leaf\n                        node = {\n                            children: items.slice(left, right + 1),\n                            height: 1,\n                            bbox: null,\n                            leaf: true\n                        };\n                        calcBBox(node, this.toBBox);\n                        return node;\n                    }\n\n                    if (!height) {\n                        // target height of the bulk-loaded tree\n                        height = Math.ceil(Math.log(N) / Math.log(M));\n\n                        // target number of root entries to maximize storage utilization\n                        M = Math.ceil(N / Math.pow(M, height - 1));\n                    }\n\n                    // TODO eliminate recursion?\n\n                    node = {\n                        children: [],\n                        height: height,\n                        bbox: null\n                    };\n\n                    // split the items into M mostly square tiles\n\n                    var N2 = Math.ceil(N / M),\n                        N1 = N2 * Math.ceil(Math.sqrt(M)),\n                        i,\n                        j,\n                        right2,\n                        right3;\n\n                    multiSelect(items, left, right, N1, this.compareMinX);\n\n                    for (i = left; i <= right; i += N1) {\n\n                        right2 = Math.min(i + N1 - 1, right);\n\n                        multiSelect(items, i, right2, N2, this.compareMinY);\n\n                        for (j = i; j <= right2; j += N2) {\n\n                            right3 = Math.min(j + N2 - 1, right2);\n\n                            // pack each entry recursively\n                            node.children.push(this._build(items, j, right3, height - 1));\n                        }\n                    }\n\n                    calcBBox(node, this.toBBox);\n\n                    return node;\n                },\n\n                _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n\n                    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n                    while (true) {\n                        path.push(node);\n\n                        if (node.leaf || path.length - 1 === level) break;\n\n                        minArea = minEnlargement = Infinity;\n\n                        for (i = 0, len = node.children.length; i < len; i++) {\n                            child = node.children[i];\n                            area = bboxArea(child.bbox);\n                            enlargement = enlargedArea(bbox, child.bbox) - area;\n\n                            // choose entry with the least area enlargement\n                            if (enlargement < minEnlargement) {\n                                minEnlargement = enlargement;\n                                minArea = area < minArea ? area : minArea;\n                                targetNode = child;\n                            } else if (enlargement === minEnlargement) {\n                                // otherwise choose one with the smallest area\n                                if (area < minArea) {\n                                    minArea = area;\n                                    targetNode = child;\n                                }\n                            }\n                        }\n\n                        node = targetNode;\n                    }\n\n                    return node;\n                },\n\n                _insert: function _insert(item, level, isNode) {\n\n                    var toBBox = this.toBBox,\n                        bbox = isNode ? item.bbox : toBBox(item),\n                        insertPath = [];\n\n                    // find the best node for accommodating the item, saving all nodes along the path too\n                    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n                    // put the item into the node\n                    node.children.push(item);\n                    extend(node.bbox, bbox);\n\n                    // split on node overflow; propagate upwards if necessary\n                    while (level >= 0) {\n                        if (insertPath[level].children.length > this._maxEntries) {\n                            this._split(insertPath, level);\n                            level--;\n                        } else break;\n                    }\n\n                    // adjust bboxes along the insertion path\n                    this._adjustParentBBoxes(bbox, insertPath, level);\n                },\n\n                // split overflowed node into two\n                _split: function _split(insertPath, level) {\n\n                    var node = insertPath[level],\n                        M = node.children.length,\n                        m = this._minEntries;\n\n                    this._chooseSplitAxis(node, m, M);\n\n                    var newNode = {\n                        children: node.children.splice(this._chooseSplitIndex(node, m, M)),\n                        height: node.height\n                    };\n\n                    if (node.leaf) newNode.leaf = true;\n\n                    calcBBox(node, this.toBBox);\n                    calcBBox(newNode, this.toBBox);\n\n                    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n                },\n\n                _splitRoot: function _splitRoot(node, newNode) {\n                    // split root node\n                    this.data = {\n                        children: [node, newNode],\n                        height: node.height + 1\n                    };\n                    calcBBox(this.data, this.toBBox);\n                },\n\n                _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n\n                    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n                    minOverlap = minArea = Infinity;\n\n                    for (i = m; i <= M - m; i++) {\n                        bbox1 = distBBox(node, 0, i, this.toBBox);\n                        bbox2 = distBBox(node, i, M, this.toBBox);\n\n                        overlap = intersectionArea(bbox1, bbox2);\n                        area = bboxArea(bbox1) + bboxArea(bbox2);\n\n                        // choose distribution with minimum overlap\n                        if (overlap < minOverlap) {\n                            minOverlap = overlap;\n                            index = i;\n\n                            minArea = area < minArea ? area : minArea;\n                        } else if (overlap === minOverlap) {\n                            // otherwise choose distribution with minimum area\n                            if (area < minArea) {\n                                minArea = area;\n                                index = i;\n                            }\n                        }\n                    }\n\n                    return index;\n                },\n\n                // sorts node children by the best axis for split\n                _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n\n                    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n                        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n                        xMargin = this._allDistMargin(node, m, M, compareMinX),\n                        yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n                    // if total distributions margin value is minimal for x, sort by minX,\n                    // otherwise it's already sorted by minY\n                    if (xMargin < yMargin) node.children.sort(compareMinX);\n                },\n\n                // total margin of all possible split distributions where each node is at least m full\n                _allDistMargin: function _allDistMargin(node, m, M, compare) {\n\n                    node.children.sort(compare);\n\n                    var toBBox = this.toBBox,\n                        leftBBox = distBBox(node, 0, m, toBBox),\n                        rightBBox = distBBox(node, M - m, M, toBBox),\n                        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n                        i,\n                        child;\n\n                    for (i = m; i < M - m; i++) {\n                        child = node.children[i];\n                        extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);\n                        margin += bboxMargin(leftBBox);\n                    }\n\n                    for (i = M - m - 1; i >= m; i--) {\n                        child = node.children[i];\n                        extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);\n                        margin += bboxMargin(rightBBox);\n                    }\n\n                    return margin;\n                },\n\n                _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n                    // adjust bboxes along the given tree path\n                    for (var i = level; i >= 0; i--) {\n                        extend(path[i].bbox, bbox);\n                    }\n                },\n\n                _condense: function _condense(path) {\n                    // go through the path, removing empty nodes and updating bboxes\n                    for (var i = path.length - 1, siblings; i >= 0; i--) {\n                        if (path[i].children.length === 0) {\n                            if (i > 0) {\n                                siblings = path[i - 1].children;\n                                siblings.splice(siblings.indexOf(path[i]), 1);\n                            } else this.clear();\n                        } else calcBBox(path[i], this.toBBox);\n                    }\n                },\n\n                _initFormat: function _initFormat(format) {\n                    // data format (minX, minY, maxX, maxY accessors)\n\n                    // uses eval-type function compilation instead of just accepting a toBBox function\n                    // because the algorithms are very sensitive to sorting functions performance,\n                    // so they should be dead simple and without inner calls\n\n                    // jshint evil: true\n\n                    var compareArr = ['return a', ' - b', ';'];\n\n                    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n                    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n                    this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');\n                }\n            };\n\n            // calculate node's bbox from bboxes of its children\n            function calcBBox(node, toBBox) {\n                node.bbox = distBBox(node, 0, node.children.length, toBBox);\n            }\n\n            // min bounding rectangle of node children from k to p-1\n            function distBBox(node, k, p, toBBox) {\n                var bbox = empty();\n\n                for (var i = k, child; i < p; i++) {\n                    child = node.children[i];\n                    extend(bbox, node.leaf ? toBBox(child) : child.bbox);\n                }\n\n                return bbox;\n            }\n\n            function empty() {\n                return [Infinity, Infinity, -Infinity, -Infinity];\n            }\n\n            function extend(a, b) {\n                a[0] = Math.min(a[0], b[0]);\n                a[1] = Math.min(a[1], b[1]);\n                a[2] = Math.max(a[2], b[2]);\n                a[3] = Math.max(a[3], b[3]);\n                return a;\n            }\n\n            function compareNodeMinX(a, b) {\n                return a.bbox[0] - b.bbox[0];\n            }\n            function compareNodeMinY(a, b) {\n                return a.bbox[1] - b.bbox[1];\n            }\n\n            function bboxArea(a) {\n                return (a[2] - a[0]) * (a[3] - a[1]);\n            }\n            function bboxMargin(a) {\n                return a[2] - a[0] + (a[3] - a[1]);\n            }\n\n            function enlargedArea(a, b) {\n                return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) * (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));\n            }\n\n            function intersectionArea(a, b) {\n                var minX = Math.max(a[0], b[0]),\n                    minY = Math.max(a[1], b[1]),\n                    maxX = Math.min(a[2], b[2]),\n                    maxY = Math.min(a[3], b[3]);\n\n                return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n            }\n\n            function contains(a, b) {\n                return a[0] <= b[0] && a[1] <= b[1] && b[2] <= a[2] && b[3] <= a[3];\n            }\n\n            function intersects(a, b) {\n                return b[0] <= a[2] && b[1] <= a[3] && b[2] >= a[0] && b[3] >= a[1];\n            }\n\n            // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n            // combines selection algorithm with binary divide & conquer approach\n\n            function multiSelect(arr, left, right, n, compare) {\n                var stack = [left, right],\n                    mid;\n\n                while (stack.length) {\n                    right = stack.pop();\n                    left = stack.pop();\n\n                    if (right - left <= n) continue;\n\n                    mid = left + Math.ceil((right - left) / n / 2) * n;\n                    select(arr, left, right, mid, compare);\n\n                    stack.push(left, mid, mid, right);\n                }\n            }\n\n            // sort array between left and right (inclusive) so that the smallest k elements come first (unordered)\n            function select(arr, left, right, k, compare) {\n                var n, i, z, s, sd, newLeft, newRight, t, j;\n\n                while (right > left) {\n                    if (right - left > 600) {\n                        n = right - left + 1;\n                        i = k - left + 1;\n                        z = Math.log(n);\n                        s = 0.5 * Math.exp(2 * z / 3);\n                        sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);\n                        newLeft = Math.max(left, Math.floor(k - i * s / n + sd));\n                        newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));\n                        select(arr, newLeft, newRight, k, compare);\n                    }\n\n                    t = arr[k];\n                    i = left;\n                    j = right;\n\n                    swap(arr, left, k);\n                    if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n                    while (i < j) {\n                        swap(arr, i, j);\n                        i++;\n                        j--;\n                        while (compare(arr[i], t) < 0) {\n                            i++;\n                        }while (compare(arr[j], t) > 0) {\n                            j--;\n                        }\n                    }\n\n                    if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n                        j++;\n                        swap(arr, j, right);\n                    }\n\n                    if (j <= k) left = j + 1;\n                    if (k <= j) right = j - 1;\n                }\n            }\n\n            function swap(arr, i, j) {\n                var tmp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = tmp;\n            }\n\n            // export as AMD/CommonJS module or global variable\n            if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n                return rbush;\n            }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if (typeof module !== 'undefined') module.exports = rbush;else if (typeof self !== 'undefined') self.rbush = rbush;else window.rbush = rbush;\n        }();\n\n        collection.features.forEach(indexFeature);\n        this.rtree = new rbush().RBush().load(bboxes);\n        this.polygons = polygons;\n    };\n\n    if (featureCollection !== undefined) {\n        this.loadFeatureCollection(featureCollection);\n    }\n}\n\n/**\r\n * Find the polygon that a point intersects. Execute a bounding-box search to\r\n * narrow down the candidate polygons to a small subset, and then perform\r\n * additional point-in-polygon intersections to resolve any ambiguities.\r\n *\r\n * @param {number} x The x-coordinate of the point.\r\n * @param {number} y The y-coordinate of the point.\r\n * @return {undefined|object} If one or more bounding box intersections are\r\n *    found, return the first polygon that intersects (`x`, `y`); otherwise,\r\n *    `undefined`.\r\n *\r\nPolygonLookup.prototype.search = function search( x, y ){\r\n  var bboxes = this.rtree.search( [ x, y, x, y ] );\r\n  var pt = [ x, y ];\r\n  for( var ind = 0; ind < bboxes.length; ind++ ){\r\n    var polyObj = this.polygons[ bboxes[ ind ].polyId ];\r\n    var polyCoords = polyObj.geometry.coordinates[ 0 ];\r\n    if( pointInPolygon( pt, polyCoords ) ){\r\n      var inHole = false;\r\n      for( var subPolyInd = 1; subPolyInd < polyObj.geometry.coordinates.length; subPolyInd++ ){\r\n        if( pointInPolygon( pt, polyObj.geometry.coordinates[ subPolyInd ] ) ){\r\n          inHole = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if( !inHole ){\r\n        return polyObj;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n*/\n/**\r\n * Build a spatial index for a set of polygons, and store both the polygons and\r\n * the index in this `PolygonLookup`.\r\n *\r\n * @param {object} collection A GeoJSON-formatted FeatureCollection.\r\n *\r\nPolygonLookup.prototype.loadFeatureCollection = function loadFeatureCollection( collection ){\r\n  var bboxes = [];\r\n  var polygons = [];\r\n  var polyId = 0;\r\n\r\n  function indexPolygon( poly ){\r\n    polygons.push(poly);\r\n    var bbox = getBoundingBox( poly.geometry.coordinates[ 0 ] );\r\n    bbox.polyId = polyId++;\r\n    bboxes.push(bbox);\r\n  }\r\n\r\n  function indexFeature( poly ){\r\n    if( poly.geometry.coordinates[ 0 ] !== undefined &&\r\n        poly.geometry.coordinates[ 0 ].length > 0){\r\n      switch( poly.geometry.type ){\r\n        case 'Polygon':\r\n          indexPolygon( poly );\r\n          break;\r\n\r\n        case 'MultiPolygon':\r\n          var childPolys = poly.geometry.coordinates;\r\n          for( var ind = 0; ind < childPolys.length; ind++ ){\r\n            var childPoly = {\r\n              type: 'Feature',\r\n              properties: poly.properties,\r\n              geometry: {\r\n                type: 'Polygon',\r\n                coordinates: childPolys[ ind ]\r\n              }\r\n            };\r\n            indexPolygon( childPoly );\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  collection.features.forEach( indexFeature );\r\n  this.rtree = new RBush().load( bboxes );\r\n  this.polygons = polygons;\r\n};\r\n\r\n*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3J0cmVlLmpzPzI4OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEV4cG9ydHMgYSBgUG9seWdvbkxvb2t1cGAgY29uc3RydWN0b3IsIHdoaWNoIGNvbnN0cnVjdHMgYSBkYXRhLXN0cnVjdHVyZSBmb3JcclxuICogcXVpY2tseSBmaW5kaW5nIHRoZSBwb2x5Z29uIHRoYXQgYSBwb2ludCBpbnRlcnNlY3RzIGluIGEgKHBvdGVudGlhbGx5IHZlcnlcclxuICogbGFyZ2UpIHNldC5cclxuICovXHJcblxyXG52YXIgcG9pbnRJblBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnQsIHZzKSB7XHJcbiAgICAvLyByYXktY2FzdGluZyBhbGdvcml0aG0gYmFzZWQgb25cclxuICAgIC8vIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWxcclxuXHJcbiAgICB2YXIgeCA9IHBvaW50WzBdLCB5ID0gcG9pbnRbMV07XHJcblxyXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB2cy5sZW5ndGggLSAxOyBpIDwgdnMubGVuZ3RoOyBqID0gaSsrKSB7XHJcbiAgICAgICAgdmFyIHhpID0gdnNbaV1bMF0sIHlpID0gdnNbaV1bMV07XHJcbiAgICAgICAgdmFyIHhqID0gdnNbal1bMF0sIHlqID0gdnNbal1bMV07XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSAoKHlpID4geSkgIT0gKHlqID4geSkpXHJcbiAgICAgICAgICAgICYmICh4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWRlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcm9wZXJ0eSB7cmJ1c2h9IHJ0cmVlIEEgc3BhdGlhbCBpbmRleCBmb3IgYHRoaXMucG9seWdvbnNgLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gcG9sZ29ucyBBIEdlb0pTT04gZmVhdHVyZSBjb2xsZWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW2ZlYXR1cmVDb2xsZWN0aW9uXSBBbiBvcHRpb25hbCBHZW9KU09OIGZlYXR1cmUgY29sbGVjdGlvblxyXG4gKiAgICB0byBwYXNzIHRvIGBsb2FkRmVhdHVyZUNvbGxlY3Rpb24oKWAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gUG9seWdvbkxvb2t1cChmZWF0dXJlQ29sbGVjdGlvbikge1xyXG4gICAgdGhpcy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goeCwgeSkge1xyXG4gICAgICAgIHZhciBiYm94ZXMgPSB0aGlzLnJ0cmVlLnNlYXJjaChbeCwgeSwgeCwgeV0pO1xyXG4gICAgICAgIHZhciBwdCA9IFt4LCB5XTtcclxuICAgICAgICBmb3IgKHZhciBpbmQgPSAwOyBpbmQgPCBiYm94ZXMubGVuZ3RoOyBpbmQrKykge1xyXG4gICAgICAgICAgICB2YXIgcG9seU9iaiA9IHRoaXMucG9seWdvbnNbYmJveGVzW2luZF0ucG9seUlkXTtcclxuICAgICAgICAgICAgdmFyIHBvbHlDb29yZHMgPSBwb2x5T2JqLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRJblBvbHlnb24ocHQsIHBvbHlDb29yZHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5Ib2xlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzdWJQb2x5SW5kID0gMTsgc3ViUG9seUluZCA8IHBvbHlPYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBzdWJQb2x5SW5kKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJblBvbHlnb24ocHQsIHBvbHlPYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXNbc3ViUG9seUluZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWluSG9sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5T2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmxvYWRGZWF0dXJlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGxvYWRGZWF0dXJlQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGJib3hlcyA9IFtdO1xyXG4gICAgICAgIHZhciBwb2x5Z29ucyA9IFtdO1xyXG4gICAgICAgIHZhciBwb2x5SWQgPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2x5KSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFB0ID0gcG9seVswXTtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBbXHJcbiAgICAgICAgICAgICAgICBmaXJzdFB0WzBdLCBmaXJzdFB0WzFdLFxyXG4gICAgICAgICAgICAgICAgZmlyc3RQdFswXSwgZmlyc3RQdFsxXVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kID0gMTsgaW5kIDwgcG9seS5sZW5ndGg7IGluZCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHQgPSBwb2x5W2luZF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBwdFswXTtcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgYmJveFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA+IGJib3hbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzJdID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHB0WzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCBiYm94WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFsxXSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ID4gYmJveFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbM10gPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmJveDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluZGV4UG9seWdvbihwb2x5KSB7XHJcbiAgICAgICAgICAgIHBvbHlnb25zLnB1c2gocG9seSk7XHJcbiAgICAgICAgICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9seS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XHJcbiAgICAgICAgICAgIGJib3gucG9seUlkID0gcG9seUlkKys7XHJcbiAgICAgICAgICAgIGJib3hlcy5wdXNoKGJib3gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5kZXhGZWF0dXJlKHBvbHkpIHtcclxuICAgICAgICAgICAgaWYgKHBvbHkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgcG9seS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBvbHkuZ2VvbWV0cnkudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1BvbHlnb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBvbHlnb24ocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQb2x5cyA9IHBvbHkuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZCA9IDA7IGluZCA8IGNoaWxkUG9seXMubGVuZ3RoOyBpbmQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUG9seSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcG9seS5wcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNoaWxkUG9seXNbaW5kXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBvbHlnb24oY2hpbGRQb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJCdXNoID0gKGZ1bmN0aW9uIHJidXNoKCkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5SQnVzaCA9IGZ1bmN0aW9uIChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBqc2hpbnQgbmV3Y2FwOiBmYWxzZSwgdmFsaWR0aGlzOiB0cnVlXHJcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUkJ1c2gpKSByZXR1cm4gbmV3IFJCdXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFJCdXNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgICAgICAgICBhbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlLmJib3gpKSByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3g6IGVtcHR5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWY6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbm9kZS5jaGlsZHJlbi5pbmRleE9mKGl0ZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUuYmJveCwgYmJveCkpIHsgLy8gZ28gZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXHJcblxyXG4gICAgICAgICAgICAgICAgY29tcGFyZU1pblg6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSxcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE4gPD0gTSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJib3g6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBlbGltaW5hdGUgcmVjdXJzaW9uP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBub2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94OiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZC5iYm94KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkLmJib3gpIC0gYXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0uYmJveCA6IHRvQkJveChpdGVtKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQobm9kZS5iYm94LCBiYm94KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXHJcbiAgICAgICAgICAgICAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5zcGxpY2UodGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSBuZXdOb2RlLmxlYWYgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtub2RlLCBuZXdOb2RlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCArIDFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcclxuICAgICAgICAgICAgICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxyXG4gICAgICAgICAgICAgICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSwgY2hpbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLmJib3gsIGJib3gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganNoaW50IGV2aWw6IHRydWVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsICdyZXR1cm4gW2EnICsgZm9ybWF0LmpvaW4oJywgYScpICsgJ107Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuYmJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZW1wdHkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKGJib3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmJveDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZW1wdHkoKSB7IHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07IH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBhWzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XHJcbiAgICAgICAgICAgICAgICBhWzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XHJcbiAgICAgICAgICAgICAgICBhWzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XHJcbiAgICAgICAgICAgICAgICBhWzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEuYmJveFswXSAtIGIuYmJveFswXTsgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdOyB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBiYm94QXJlYShhKSB7IHJldHVybiAoYVsyXSAtIGFbMF0pICogKGFbM10gLSBhWzFdKTsgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhWzJdIC0gYVswXSkgKyAoYVszXSAtIGFbMV0pOyB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLm1heChiWzJdLCBhWzJdKSAtIE1hdGgubWluKGJbMF0sIGFbMF0pKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgKE1hdGgubWF4KGJbM10sIGFbM10pIC0gTWF0aC5taW4oYlsxXSwgYVsxXSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYVswXSwgYlswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1pbihhWzJdLCBiWzJdKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5taW4oYVszXSwgYlszXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXSA8PSBiWzBdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYVsxXSA8PSBiWzFdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYlsyXSA8PSBhWzJdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYlszXSA8PSBhWzNdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGFbMl0gJiZcclxuICAgICAgICAgICAgICAgICAgICBiWzFdIDw9IGFbM10gJiZcclxuICAgICAgICAgICAgICAgICAgICBiWzJdID49IGFbMF0gJiZcclxuICAgICAgICAgICAgICAgICAgICBiWzNdID49IGFbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xyXG4gICAgICAgICAgICAvLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWlkO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG1pZCwgY29tcGFyZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc29ydCBhcnJheSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IChpbmNsdXNpdmUpIHNvIHRoYXQgdGhlIHNtYWxsZXN0IGsgZWxlbWVudHMgY29tZSBmaXJzdCAodW5vcmRlcmVkKVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgaywgY29tcGFyZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG4sIGksIHosIHMsIHNkLCBuZXdMZWZ0LCBuZXdSaWdodCwgdCwgajtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGsgLSBsZWZ0ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IE1hdGgubG9nKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAoaSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBpICogcyAvIG4gKyBzZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIGkpICogcyAvIG4gKyBzZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QoYXJyLCBuZXdMZWZ0LCBuZXdSaWdodCwgaywgY29tcGFyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ID0gYXJyW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGogPSByaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGFycltpXTtcclxuICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltqXTtcclxuICAgICAgICAgICAgICAgIGFycltqXSA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGV4cG9ydCBhcyBBTUQvQ29tbW9uSlMgbW9kdWxlIG9yIGdsb2JhbCB2YXJpYWJsZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmJ1c2g7IH0pO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnJidXNoID0gcmJ1c2g7XHJcbiAgICAgICAgICAgIGVsc2Ugd2luZG93LnJidXNoID0gcmJ1c2g7XHJcblxyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgIGNvbGxlY3Rpb24uZmVhdHVyZXMuZm9yRWFjaChpbmRleEZlYXR1cmUpO1xyXG4gICAgICAgIHRoaXMucnRyZWUgPSAobmV3IHJidXNoKCkpLlJCdXNoKCkubG9hZChiYm94ZXMpO1xyXG4gICAgICAgIHRoaXMucG9seWdvbnMgPSBwb2x5Z29ucztcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgaWYgKGZlYXR1cmVDb2xsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLmxvYWRGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBwb2x5Z29uIHRoYXQgYSBwb2ludCBpbnRlcnNlY3RzLiBFeGVjdXRlIGEgYm91bmRpbmctYm94IHNlYXJjaCB0b1xyXG4gKiBuYXJyb3cgZG93biB0aGUgY2FuZGlkYXRlIHBvbHlnb25zIHRvIGEgc21hbGwgc3Vic2V0LCBhbmQgdGhlbiBwZXJmb3JtXHJcbiAqIGFkZGl0aW9uYWwgcG9pbnQtaW4tcG9seWdvbiBpbnRlcnNlY3Rpb25zIHRvIHJlc29sdmUgYW55IGFtYmlndWl0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXHJcbiAqIEByZXR1cm4ge3VuZGVmaW5lZHxvYmplY3R9IElmIG9uZSBvciBtb3JlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb25zIGFyZVxyXG4gKiAgICBmb3VuZCwgcmV0dXJuIHRoZSBmaXJzdCBwb2x5Z29uIHRoYXQgaW50ZXJzZWN0cyAoYHhgLCBgeWApOyBvdGhlcndpc2UsXHJcbiAqICAgIGB1bmRlZmluZWRgLlxyXG4gKlxyXG5Qb2x5Z29uTG9va3VwLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goIHgsIHkgKXtcclxuICB2YXIgYmJveGVzID0gdGhpcy5ydHJlZS5zZWFyY2goIFsgeCwgeSwgeCwgeSBdICk7XHJcbiAgdmFyIHB0ID0gWyB4LCB5IF07XHJcbiAgZm9yKCB2YXIgaW5kID0gMDsgaW5kIDwgYmJveGVzLmxlbmd0aDsgaW5kKysgKXtcclxuICAgIHZhciBwb2x5T2JqID0gdGhpcy5wb2x5Z29uc1sgYmJveGVzWyBpbmQgXS5wb2x5SWQgXTtcclxuICAgIHZhciBwb2x5Q29vcmRzID0gcG9seU9iai5nZW9tZXRyeS5jb29yZGluYXRlc1sgMCBdO1xyXG4gICAgaWYoIHBvaW50SW5Qb2x5Z29uKCBwdCwgcG9seUNvb3JkcyApICl7XHJcbiAgICAgIHZhciBpbkhvbGUgPSBmYWxzZTtcclxuICAgICAgZm9yKCB2YXIgc3ViUG9seUluZCA9IDE7IHN1YlBvbHlJbmQgPCBwb2x5T2JqLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgc3ViUG9seUluZCsrICl7XHJcbiAgICAgICAgaWYoIHBvaW50SW5Qb2x5Z29uKCBwdCwgcG9seU9iai5nZW9tZXRyeS5jb29yZGluYXRlc1sgc3ViUG9seUluZCBdICkgKXtcclxuICAgICAgICAgIGluSG9sZSA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKCAhaW5Ib2xlICl7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlPYmo7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4qL1xyXG4vKipcclxuICogQnVpbGQgYSBzcGF0aWFsIGluZGV4IGZvciBhIHNldCBvZiBwb2x5Z29ucywgYW5kIHN0b3JlIGJvdGggdGhlIHBvbHlnb25zIGFuZFxyXG4gKiB0aGUgaW5kZXggaW4gdGhpcyBgUG9seWdvbkxvb2t1cGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb2xsZWN0aW9uIEEgR2VvSlNPTi1mb3JtYXR0ZWQgRmVhdHVyZUNvbGxlY3Rpb24uXHJcbiAqXHJcblBvbHlnb25Mb29rdXAucHJvdG90eXBlLmxvYWRGZWF0dXJlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGxvYWRGZWF0dXJlQ29sbGVjdGlvbiggY29sbGVjdGlvbiApe1xyXG4gIHZhciBiYm94ZXMgPSBbXTtcclxuICB2YXIgcG9seWdvbnMgPSBbXTtcclxuICB2YXIgcG9seUlkID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gaW5kZXhQb2x5Z29uKCBwb2x5ICl7XHJcbiAgICBwb2x5Z29ucy5wdXNoKHBvbHkpO1xyXG4gICAgdmFyIGJib3ggPSBnZXRCb3VuZGluZ0JveCggcG9seS5nZW9tZXRyeS5jb29yZGluYXRlc1sgMCBdICk7XHJcbiAgICBiYm94LnBvbHlJZCA9IHBvbHlJZCsrO1xyXG4gICAgYmJveGVzLnB1c2goYmJveCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbmRleEZlYXR1cmUoIHBvbHkgKXtcclxuICAgIGlmKCBwb2x5Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWyAwIF0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIHBvbHkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbIDAgXS5sZW5ndGggPiAwKXtcclxuICAgICAgc3dpdGNoKCBwb2x5Lmdlb21ldHJ5LnR5cGUgKXtcclxuICAgICAgICBjYXNlICdQb2x5Z29uJzpcclxuICAgICAgICAgIGluZGV4UG9seWdvbiggcG9seSApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XHJcbiAgICAgICAgICB2YXIgY2hpbGRQb2x5cyA9IHBvbHkuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgICBmb3IoIHZhciBpbmQgPSAwOyBpbmQgPCBjaGlsZFBvbHlzLmxlbmd0aDsgaW5kKysgKXtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUG9seSA9IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgICAgICAgcHJvcGVydGllczogcG9seS5wcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUG9seWdvbicsXHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogY2hpbGRQb2x5c1sgaW5kIF1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGluZGV4UG9seWdvbiggY2hpbGRQb2x5ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29sbGVjdGlvbi5mZWF0dXJlcy5mb3JFYWNoKCBpbmRleEZlYXR1cmUgKTtcclxuICB0aGlzLnJ0cmVlID0gbmV3IFJCdXNoKCkubG9hZCggYmJveGVzICk7XHJcbiAgdGhpcy5wb2x5Z29ucyA9IHBvbHlnb25zO1xyXG59O1xyXG5cclxuKi9cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3J0cmVlLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQWdDQTtBQWhDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcmFBO0FBQ0E7QUF3YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv1.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./ES6Test/Gisplay */ 0);\n\nmodule.exports = {\n    createBGMap: function createBGMap() {\n        console.log(\"Start gisplayv2.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        //var data = new Array();\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            //new Choropleth(map, null,options);\n\n            var data = JSON.parse(reader.result);\n            //console.log(data);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            /* console.log(window.map)\r\n             console.log(map)*/\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n}; /**\r\n    * This file is the entry point for the Gisplay API\r\n    *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dpc3BsYXl2MS5qcz9kZjBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciB0aGUgR2lzcGxheSBBUElcclxuICovXHJcbmltcG9ydCB7R2lzcGxheX0gZnJvbSAnLi9FUzZUZXN0L0dpc3BsYXknXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNyZWF0ZUJHTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydCBnaXNwbGF5djIuXCIpO1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guc3RyZWV0cycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDaG9yb3BsZXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb2xvclNjaGVtZTogW1wid2hpdGVcIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl1cclxuICAgICAgICAgICAgLCBudW1iZXJPZkNsYXNzZXM6IDRcclxuICAgICAgICAgICAgLCBhdHRyOiAnZjMnXHJcbiAgICAgICAgICAgICwgbGVnZW5kVGl0bGU6ICdGYXRhbHMnXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL3ZhciBkYXRhID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL25ldyBDaG9yb3BsZXRoKG1hcCwgbnVsbCxvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdmFyIGRhdGFyZWFkdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBkZSBsZWl0dXJhIGRvIGZpY2hlaXJvOiBcIiArIChkYXRhcmVhZHRpbWVzdGFtcCAtIHRpbWUpIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAvKiBjb25zb2xlLmxvZyh3aW5kb3cubWFwKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtYXApKi9cclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hvcm9wbGV0aCh3aW5kb3cubWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBnaXNwbGF5OiBcIiArIChEYXRlLm5vdygpIC0gZGF0YXJlYWR0aW1lc3RhbXApIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIHRvdGFsOiBcIiArIChEYXRlLm5vdygpIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2lzcGxheXYxLmpzIl0sIm1hcHBpbmdzIjoiOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);